/**
 * Generated by Scrooge
 *   version: 18.4.0
 *   rev: b64bcb47af2451b2e51a1ed1b3876f6c06c642b3
 *   built at: 20180410-144307
 */
package xed.userprofile.service

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob,
  ThriftService,
  ThriftStruct,
  ThriftStructCodec,
  ThriftStructFieldInfo,
  ThriftResponse,
  ThriftUtil,
  ToThriftService,
  ValidatingThriftStruct,
  ValidatingThriftStructCodec3
}
import com.twitter.finagle.{service => ctfs}
import com.twitter.finagle.thrift.{
  Protocols,
  RichClientParam,
  RichServerParam,
  ThriftClientRequest,
  ThriftServiceIface
}
import com.twitter.util.Future
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait TUserProfileService[+MM[_]] extends ThriftService {
  
  def ping(): MM[String]
  
  def checkSession(sessionId: String): MM[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]
  
  def getUserProfileBySessionID(sessionId: String): MM[xed.userprofile.domain.thrift.TFullUserInfoResp]
  
  def getUserProfileByUsername(username: String): MM[xed.userprofile.domain.thrift.TFullUserInfoResp]
  
  def getUserProfile(username: String): MM[xed.userprofile.domain.thrift.TUserProfileResp]
  
  def getProfileByEmail(email: String): MM[xed.userprofile.domain.thrift.TUserProfileResp]
  
  def multiGetUserProfiles(usernames: Set[String] = Set[String]()): MM[xed.userprofile.domain.thrift.TMultiUserProfileResp]
  
  def getUserProfiles(from: Int, size: Int): MM[xed.userprofile.domain.thrift.TUserProfileSearchResp]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object TUserProfileService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  trait ServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def checkSession : _root_.com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType]
    def getUserProfileBySessionID : _root_.com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType]
    def getUserProfileByUsername : _root_.com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType]
    def getUserProfile : _root_.com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType]
    def getProfileByEmail : _root_.com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType]
    def multiGetUserProfiles : _root_.com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType]
    def getUserProfiles : _root_.com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]

    def withPing(ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]): ServicePerEndpoint = this

    def withCheckSession(checkSession : _root_.com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType]): ServicePerEndpoint = this

    def withGetUserProfileBySessionID(getUserProfileBySessionID : _root_.com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType]): ServicePerEndpoint = this

    def withGetUserProfileByUsername(getUserProfileByUsername : _root_.com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType]): ServicePerEndpoint = this

    def withGetUserProfile(getUserProfile : _root_.com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType]): ServicePerEndpoint = this

    def withGetProfileByEmail(getProfileByEmail : _root_.com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType]): ServicePerEndpoint = this

    def withMultiGetUserProfiles(multiGetUserProfiles : _root_.com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType]): ServicePerEndpoint = this

    def withGetUserProfiles(getUserProfiles : _root_.com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]): ServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = MethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  trait ReqRepServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.service.Filterable[ReqRepServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
    def checkSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CheckSession.Args], _root_.com.twitter.scrooge.Response[self.CheckSession.SuccessType]]
    def getUserProfileBySessionID : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileBySessionID.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileBySessionID.SuccessType]]
    def getUserProfileByUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileByUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileByUsername.SuccessType]]
    def getUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfile.SuccessType]]
    def getProfileByEmail : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProfileByEmail.Args], _root_.com.twitter.scrooge.Response[self.GetProfileByEmail.SuccessType]]
    def multiGetUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.MultiGetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.MultiGetUserProfiles.SuccessType]]
    def getUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfiles.SuccessType]]

    def withPing(ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCheckSession(checkSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CheckSession.Args], _root_.com.twitter.scrooge.Response[self.CheckSession.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserProfileBySessionID(getUserProfileBySessionID : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileBySessionID.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileBySessionID.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserProfileByUsername(getUserProfileByUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileByUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileByUsername.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserProfile(getUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfile.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetProfileByEmail(getProfileByEmail : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProfileByEmail.Args], _root_.com.twitter.scrooge.Response[self.GetProfileByEmail.SuccessType]]): ReqRepServicePerEndpoint = this

    def withMultiGetUserProfiles(multiGetUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.MultiGetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.MultiGetUserProfiles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserProfiles(getUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfiles.SuccessType]]): ReqRepServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = ReqRepMethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  trait BaseServiceIface extends ToThriftService {
    def ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def checkSession : com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType]
    def getUserProfileBySessionID : com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType]
    def getUserProfileByUsername : com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType]
    def getUserProfile : com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType]
    def getProfileByEmail : com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType]
    def multiGetUserProfiles : com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType]
    def getUserProfiles : com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]

    def toThriftService: ThriftService = new MethodIface(this)
  }

  object ServicePerEndpoint {

    def apply(
      ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      checkSession : _root_.com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType],
      getUserProfileBySessionID : _root_.com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType],
      getUserProfileByUsername : _root_.com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType],
      getUserProfile : _root_.com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType],
      getProfileByEmail : _root_.com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType],
      multiGetUserProfiles : _root_.com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType],
      getUserProfiles : _root_.com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]
    ): ServicePerEndpoint = new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

    private final class ServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      override val checkSession : _root_.com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType],
      override val getUserProfileBySessionID : _root_.com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType],
      override val getUserProfileByUsername : _root_.com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType],
      override val getUserProfile : _root_.com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType],
      override val getProfileByEmail : _root_.com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType],
      override val multiGetUserProfiles : _root_.com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType],
      override val getUserProfiles : _root_.com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]
    ) extends ServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withCheckSession(
        checkSession : _root_.com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withGetUserProfileBySessionID(
        getUserProfileBySessionID : _root_.com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withGetUserProfileByUsername(
        getUserProfileByUsername : _root_.com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withGetUserProfile(
        getUserProfile : _root_.com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withGetProfileByEmail(
        getProfileByEmail : _root_.com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withMultiGetUserProfiles(
        multiGetUserProfiles : _root_.com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def withGetUserProfiles(
        getUserProfiles : _root_.com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint =
        new ServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          checkSession = filter.toFilter.andThen(checkSession),
          getUserProfileBySessionID = filter.toFilter.andThen(getUserProfileBySessionID),
          getUserProfileByUsername = filter.toFilter.andThen(getUserProfileByUsername),
          getUserProfile = filter.toFilter.andThen(getUserProfile),
          getProfileByEmail = filter.toFilter.andThen(getProfileByEmail),
          multiGetUserProfiles = filter.toFilter.andThen(multiGetUserProfiles),
          getUserProfiles = filter.toFilter.andThen(getUserProfiles)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.checkSession,
          this.getUserProfileBySessionID,
          this.getUserProfileByUsername,
          this.getUserProfile,
          this.getProfileByEmail,
          this.multiGetUserProfiles,
          this.getUserProfiles
        )
    }
  }

  object ReqRepServicePerEndpoint {

    def apply(
      ping :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      checkSession :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CheckSession.Args], _root_.com.twitter.scrooge.Response[self.CheckSession.SuccessType]],
      getUserProfileBySessionID :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfileBySessionID.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileBySessionID.SuccessType]],
      getUserProfileByUsername :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfileByUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileByUsername.SuccessType]],
      getUserProfile :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfile.SuccessType]],
      getProfileByEmail :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProfileByEmail.Args], _root_.com.twitter.scrooge.Response[self.GetProfileByEmail.SuccessType]],
      multiGetUserProfiles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.MultiGetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.MultiGetUserProfiles.SuccessType]],
      getUserProfiles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfiles.SuccessType]]
    ): ReqRepServicePerEndpoint =
      new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

    private final class ReqRepServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      override val checkSession : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CheckSession.Args], _root_.com.twitter.scrooge.Response[self.CheckSession.SuccessType]],
      override val getUserProfileBySessionID : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfileBySessionID.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileBySessionID.SuccessType]],
      override val getUserProfileByUsername : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfileByUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileByUsername.SuccessType]],
      override val getUserProfile : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfile.SuccessType]],
      override val getProfileByEmail : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProfileByEmail.Args], _root_.com.twitter.scrooge.Response[self.GetProfileByEmail.SuccessType]],
      override val multiGetUserProfiles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.MultiGetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.MultiGetUserProfiles.SuccessType]],
      override val getUserProfiles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfiles.SuccessType]]
    ) extends ReqRepServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withCheckSession(
        checkSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CheckSession.Args], _root_.com.twitter.scrooge.Response[self.CheckSession.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withGetUserProfileBySessionID(
        getUserProfileBySessionID : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileBySessionID.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileBySessionID.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withGetUserProfileByUsername(
        getUserProfileByUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfileByUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfileByUsername.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withGetUserProfile(
        getUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfile.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withGetProfileByEmail(
        getProfileByEmail : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProfileByEmail.Args], _root_.com.twitter.scrooge.Response[self.GetProfileByEmail.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withMultiGetUserProfiles(
        multiGetUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.MultiGetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.MultiGetUserProfiles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)
      override def withGetUserProfiles(
        getUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.GetUserProfiles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, checkSession, getUserProfileBySessionID, getUserProfileByUsername, getUserProfile, getProfileByEmail, multiGetUserProfiles, getUserProfiles)

      override def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          checkSession = filter.toFilter.andThen(checkSession),
          getUserProfileBySessionID = filter.toFilter.andThen(getUserProfileBySessionID),
          getUserProfileByUsername = filter.toFilter.andThen(getUserProfileByUsername),
          getUserProfile = filter.toFilter.andThen(getUserProfile),
          getProfileByEmail = filter.toFilter.andThen(getProfileByEmail),
          multiGetUserProfiles = filter.toFilter.andThen(multiGetUserProfiles),
          getUserProfiles = filter.toFilter.andThen(getUserProfiles)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.checkSession,
          this.getUserProfileBySessionID,
          this.getUserProfileByUsername,
          this.getUserProfile,
          this.getProfileByEmail,
          this.multiGetUserProfiles,
          this.getUserProfiles
        )
    }
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  case class ServiceIface(
    ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
    checkSession : com.twitter.finagle.Service[self.CheckSession.Args, self.CheckSession.SuccessType],
    getUserProfileBySessionID : com.twitter.finagle.Service[self.GetUserProfileBySessionID.Args, self.GetUserProfileBySessionID.SuccessType],
    getUserProfileByUsername : com.twitter.finagle.Service[self.GetUserProfileByUsername.Args, self.GetUserProfileByUsername.SuccessType],
    getUserProfile : com.twitter.finagle.Service[self.GetUserProfile.Args, self.GetUserProfile.SuccessType],
    getProfileByEmail : com.twitter.finagle.Service[self.GetProfileByEmail.Args, self.GetProfileByEmail.SuccessType],
    multiGetUserProfiles : com.twitter.finagle.Service[self.MultiGetUserProfiles.Args, self.MultiGetUserProfiles.SuccessType],
    getUserProfiles : com.twitter.finagle.Service[self.GetUserProfiles.Args, self.GetUserProfiles.SuccessType]
  ) extends BaseServiceIface
    with com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServiceIface] {

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServiceIface` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ServiceIface =
      copy(
        ping = filter.toFilter.andThen(ping),
        checkSession = filter.toFilter.andThen(checkSession),
        getUserProfileBySessionID = filter.toFilter.andThen(getUserProfileBySessionID),
        getUserProfileByUsername = filter.toFilter.andThen(getUserProfileByUsername),
        getUserProfile = filter.toFilter.andThen(getUserProfile),
        getProfileByEmail = filter.toFilter.andThen(getProfileByEmail),
        multiGetUserProfiles = filter.toFilter.andThen(multiGetUserProfiles),
        getUserProfiles = filter.toFilter.andThen(getUserProfiles)
      )
  }

  implicit object ServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ServicePerEndpointBuilder[ServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServicePerEndpoint =
        ServicePerEndpoint(
          ping = ThriftServiceIface(self.Ping, thriftService, clientParam),
          checkSession = ThriftServiceIface(self.CheckSession, thriftService, clientParam),
          getUserProfileBySessionID = ThriftServiceIface(self.GetUserProfileBySessionID, thriftService, clientParam),
          getUserProfileByUsername = ThriftServiceIface(self.GetUserProfileByUsername, thriftService, clientParam),
          getUserProfile = ThriftServiceIface(self.GetUserProfile, thriftService, clientParam),
          getProfileByEmail = ThriftServiceIface(self.GetProfileByEmail, thriftService, clientParam),
          multiGetUserProfiles = ThriftServiceIface(self.MultiGetUserProfiles, thriftService, clientParam),
          getUserProfiles = ThriftServiceIface(self.GetUserProfiles, thriftService, clientParam)
        )
  }

  implicit object ReqRepServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepServicePerEndpointBuilder[ReqRepServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ReqRepServicePerEndpoint =
        ReqRepServicePerEndpoint(
          ping = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Ping, thriftService, clientParam),
          checkSession = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CheckSession, thriftService, clientParam),
          getUserProfileBySessionID = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserProfileBySessionID, thriftService, clientParam),
          getUserProfileByUsername = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserProfileByUsername, thriftService, clientParam),
          getUserProfile = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserProfile, thriftService, clientParam),
          getProfileByEmail = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetProfileByEmail, thriftService, clientParam),
          multiGetUserProfiles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.MultiGetUserProfiles, thriftService, clientParam),
          getUserProfiles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserProfiles, thriftService, clientParam)
        )
  }

  @deprecated("Use ServicePerEndpointBuilder", "2017-11-07")
  implicit object ServiceIfaceBuilder
    extends com.twitter.finagle.thrift.ServiceIfaceBuilder[ServiceIface] {
      def newServiceIface(
        binaryService: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServiceIface =
        ServiceIface(
          ping = ThriftServiceIface(self.Ping, binaryService, clientParam),
          checkSession = ThriftServiceIface(self.CheckSession, binaryService, clientParam),
          getUserProfileBySessionID = ThriftServiceIface(self.GetUserProfileBySessionID, binaryService, clientParam),
          getUserProfileByUsername = ThriftServiceIface(self.GetUserProfileByUsername, binaryService, clientParam),
          getUserProfile = ThriftServiceIface(self.GetUserProfile, binaryService, clientParam),
          getProfileByEmail = ThriftServiceIface(self.GetProfileByEmail, binaryService, clientParam),
          multiGetUserProfiles = ThriftServiceIface(self.MultiGetUserProfiles, binaryService, clientParam),
          getUserProfiles = ThriftServiceIface(self.GetUserProfiles, binaryService, clientParam)
        )
  }

  object Ping extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_result")
      val SuccessField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[String]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product1[Option[String]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[String]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[String]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "ping"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val ping$args = Ping.Args
  type ping$args = Ping.Args

  val ping$result = Ping.Result
  type ping$result = Ping.Result

  object CheckSession extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("checkSession_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String
      ): Args =
        new Args(
          sessionId
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.sessionId)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String
      ) = this(
        sessionId,
        Map.empty
      )
    
      def _1 = sessionId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TFullUserAuthInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("checkSession_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TFullUserAuthInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TFullUserAuthInfoResp = {
        xed.userprofile.domain.thrift.TFullUserAuthInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TFullUserAuthInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TFullUserAuthInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "checkSession"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val checkSession$args = CheckSession.Args
  type checkSession$args = CheckSession.Args

  val checkSession$result = CheckSession.Result
  type checkSession$result = CheckSession.Result

  object GetUserProfileBySessionID extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfileBySessionID_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String
      ): Args =
        new Args(
          sessionId
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.sessionId)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String
      ) = this(
        sessionId,
        Map.empty
      )
    
      def _1 = sessionId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TFullUserInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfileBySessionID_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TFullUserInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TFullUserInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TFullUserInfoResp = {
        xed.userprofile.domain.thrift.TFullUserInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TFullUserInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TFullUserInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TFullUserInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TFullUserInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TFullUserInfoResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TFullUserInfoResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserProfileBySessionID"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserProfileBySessionID$args = GetUserProfileBySessionID.Args
  type getUserProfileBySessionID$args = GetUserProfileBySessionID.Args

  val getUserProfileBySessionID$result = GetUserProfileBySessionID.Result
  type getUserProfileBySessionID$result = GetUserProfileBySessionID.Result

  object GetUserProfileByUsername extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfileByUsername_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TFullUserInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfileByUsername_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TFullUserInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TFullUserInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TFullUserInfoResp = {
        xed.userprofile.domain.thrift.TFullUserInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TFullUserInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TFullUserInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TFullUserInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TFullUserInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TFullUserInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TFullUserInfoResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TFullUserInfoResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserProfileByUsername"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserProfileByUsername$args = GetUserProfileByUsername.Args
  type getUserProfileByUsername$args = GetUserProfileByUsername.Args

  val getUserProfileByUsername$result = GetUserProfileByUsername.Result
  type getUserProfileByUsername$result = GetUserProfileByUsername.Result

  object GetUserProfile extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfile_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TUserProfileResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfile_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TUserProfileResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TUserProfileResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TUserProfileResp = {
        xed.userprofile.domain.thrift.TUserProfileResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TUserProfileResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TUserProfileResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TUserProfileResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TUserProfileResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TUserProfileResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TUserProfileResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TUserProfileResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserProfile"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserProfile$args = GetUserProfile.Args
  type getUserProfile$args = GetUserProfile.Args

  val getUserProfile$result = GetUserProfile.Result
  type getUserProfile$result = GetUserProfile.Result

  object GetProfileByEmail extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getProfileByEmail_args")
      val EmailField = new TField("email", TType.STRING, 1)
      val EmailFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          EmailField,
          false,
          true,
          EmailFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.email == null) throw new TProtocolException("Required field email cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.email == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.email)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          email =
            {
              val field = original.email
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var email: String = null
        var _got_email = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    email = readEmailValue(_iprot)
                    _got_email = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'email' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_email) throw new TProtocolException("Required field 'email' was not found in serialized data for struct Args")
        new Args(
          email,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        email: String
      ): Args =
        new Args(
          email
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.email)
    
    
      @inline private[service] def readEmailValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeEmailField(email_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(EmailField)
        writeEmailValue(email_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeEmailValue(email_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(email_item)
      }
    
    
    }
    
    class Args(
        val email: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        email: String
      ) = this(
        email,
        Map.empty
      )
    
      def _1 = email
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (email ne null) writeEmailField(email, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        email: String = this.email,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          email,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.email
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TUserProfileResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getProfileByEmail_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TUserProfileResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TUserProfileResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TUserProfileResp = {
        xed.userprofile.domain.thrift.TUserProfileResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TUserProfileResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TUserProfileResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TUserProfileResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TUserProfileResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TUserProfileResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TUserProfileResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TUserProfileResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getProfileByEmail"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getProfileByEmail$args = GetProfileByEmail.Args
  type getProfileByEmail$args = GetProfileByEmail.Args

  val getProfileByEmail$result = GetProfileByEmail.Result
  type getProfileByEmail$result = GetProfileByEmail.Result

  object MultiGetUserProfiles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("multiGetUserProfiles_args")
      val UsernamesField = new TField("usernames", TType.SET, 1)
      val UsernamesFieldManifest = implicitly[Manifest[Set[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernamesField,
          false,
          true,
          UsernamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.usernames == null) throw new TProtocolException("Required field usernames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.usernames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.usernames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          usernames =
            {
              val field = original.usernames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var usernames: Set[String] = Set[String]()
        var _got_usernames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.SET =>
                    usernames = readUsernamesValue(_iprot)
                    _got_usernames = true
                  case _actualType =>
                    val _expectedType = TType.SET
                    throw new TProtocolException(
                      "Received wrong type for field 'usernames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_usernames) throw new TProtocolException("Required field 'usernames' was not found in serialized data for struct Args")
        new Args(
          usernames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        usernames: Set[String] = Set[String]()
      ): Args =
        new Args(
          usernames
        )
    
      def unapply(_item: Args): _root_.scala.Option[Set[String]] = _root_.scala.Some(_item.usernames)
    
    
      @inline private[service] def readUsernamesValue(_iprot: TProtocol): Set[String] = {
        val _set = _iprot.readSetBegin()
        if (_set.size == 0) {
          _iprot.readSetEnd()
          Set.empty[String]
        } else {
          val _rv = new mutable$HashSet[String]
          var _i = 0
          while (_i < _set.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readSetEnd()
          _rv
        }
      }
    
      @inline private def writeUsernamesField(usernames_item: Set[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernamesField)
        writeUsernamesValue(usernames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernamesValue(usernames_item: Set[String], _oprot: TProtocol): Unit = {
        _oprot.writeSetBegin(new TSet(TType.STRING, usernames_item.size))
        usernames_item.foreach { usernames_item_element =>
          _oprot.writeString(usernames_item_element)
        }
        _oprot.writeSetEnd()
      }
    
    
    }
    
    class Args(
        val usernames: Set[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Set[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        usernames: Set[String] = Set[String]()
      ) = this(
        usernames,
        Map.empty
      )
    
      def _1 = usernames
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (usernames ne null) writeUsernamesField(usernames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        usernames: Set[String] = this.usernames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          usernames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.usernames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TMultiUserProfileResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("multiGetUserProfiles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TMultiUserProfileResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TMultiUserProfileResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TMultiUserProfileResp = {
        xed.userprofile.domain.thrift.TMultiUserProfileResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TMultiUserProfileResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TMultiUserProfileResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TMultiUserProfileResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TMultiUserProfileResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TMultiUserProfileResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TMultiUserProfileResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TMultiUserProfileResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TMultiUserProfileResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "multiGetUserProfiles"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val multiGetUserProfiles$args = MultiGetUserProfiles.Args
  type multiGetUserProfiles$args = MultiGetUserProfiles.Args

  val multiGetUserProfiles$result = MultiGetUserProfiles.Result
  type multiGetUserProfiles$result = MultiGetUserProfiles.Result

  object GetUserProfiles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfiles_args")
      val FromField = new TField("from", TType.I32, 1)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val SizeField = new TField("size", TType.I32, 2)
      val SizeFieldManifest = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SizeField,
          false,
          true,
          SizeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.from)
        buf ++= validateField(item.size)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          from =
            {
              val field = original.from
              field
            },
          size =
            {
              val field = original.size
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var from: Int = 0
        var _got_from = false
        var size: Int = 0
        var _got_size = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    size = readSizeValue(_iprot)
                    _got_size = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'size' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_size) throw new TProtocolException("Required field 'size' was not found in serialized data for struct Args")
        new Args(
          from,
          size,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        from: Int,
        size: Int
      ): Args =
        new Args(
          from,
          size
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readSizeValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSizeField(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SizeField)
        writeSizeValue(size_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSizeValue(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(size_item)
      }
    
    
    }
    
    class Args(
        val from: Int,
        val size: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        from: Int,
        size: Int
      ) = this(
        from,
        size,
        Map.empty
      )
    
      def _1 = from
      def _2 = size
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          from,
          size
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeFromField(from, _oprot)
        writeSizeField(size, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        from: Int = this.from,
        size: Int = this.size,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          from,
          size,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.from
        case 1 => this.size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.userprofile.domain.thrift.TUserProfileSearchResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserProfiles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.userprofile.domain.thrift.TUserProfileSearchResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.userprofile.domain.thrift.TUserProfileSearchResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.userprofile.domain.thrift.TUserProfileSearchResp = {
        xed.userprofile.domain.thrift.TUserProfileSearchResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.userprofile.domain.thrift.TUserProfileSearchResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.userprofile.domain.thrift.TUserProfileSearchResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.userprofile.domain.thrift.TUserProfileSearchResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.userprofile.domain.thrift.TUserProfileSearchResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.userprofile.domain.thrift.TUserProfileSearchResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.userprofile.domain.thrift.TUserProfileSearchResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.userprofile.domain.thrift.TUserProfileSearchResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.userprofile.domain.thrift.TUserProfileSearchResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserProfiles"
    val serviceName: String = "TUserProfileService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserProfiles$args = GetUserProfiles.Args
  type getUserProfiles$args = GetUserProfiles.Args

  val getUserProfiles$result = GetUserProfiles.Result
  type getUserProfiles$result = GetUserProfiles.Result


  trait MethodPerEndpoint
    extends TUserProfileService[Future] {
    
    def ping(): Future[String]
    
    def checkSession(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]
    
    def getUserProfileBySessionID(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp]
    
    def getUserProfileByUsername(username: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp]
    
    def getUserProfile(username: String): Future[xed.userprofile.domain.thrift.TUserProfileResp]
    
    def getProfileByEmail(email: String): Future[xed.userprofile.domain.thrift.TUserProfileResp]
    
    def multiGetUserProfiles(usernames: Set[String] = Set[String]()): Future[xed.userprofile.domain.thrift.TMultiUserProfileResp]
    
    def getUserProfiles(from: Int, size: Int): Future[xed.userprofile.domain.thrift.TUserProfileSearchResp]
  }

  object MethodPerEndpoint {

    def apply(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint = {
      new MethodPerEndpointImpl(servicePerEndpoint) {}
    }

    /**
     * Use `MethodPerEndpoint.apply()` instead of this constructor.
     */
    class MethodPerEndpointImpl protected (servicePerEndpoint: ServicePerEndpoint)
      extends MethodPerEndpoint {
        def ping(): Future[String] =
          servicePerEndpoint.ping(self.Ping.Args())
        def checkSession(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] =
          servicePerEndpoint.checkSession(self.CheckSession.Args(sessionId))
        def getUserProfileBySessionID(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] =
          servicePerEndpoint.getUserProfileBySessionID(self.GetUserProfileBySessionID.Args(sessionId))
        def getUserProfileByUsername(username: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] =
          servicePerEndpoint.getUserProfileByUsername(self.GetUserProfileByUsername.Args(username))
        def getUserProfile(username: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] =
          servicePerEndpoint.getUserProfile(self.GetUserProfile.Args(username))
        def getProfileByEmail(email: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] =
          servicePerEndpoint.getProfileByEmail(self.GetProfileByEmail.Args(email))
        def multiGetUserProfiles(usernames: Set[String] = Set[String]()): Future[xed.userprofile.domain.thrift.TMultiUserProfileResp] =
          servicePerEndpoint.multiGetUserProfiles(self.MultiGetUserProfiles.Args(usernames))
        def getUserProfiles(from: Int, size: Int): Future[xed.userprofile.domain.thrift.TUserProfileSearchResp] =
          servicePerEndpoint.getUserProfiles(self.GetUserProfiles.Args(from, size))

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  object ReqRepMethodPerEndpoint {

    def apply(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      new ReqRepMethodPerEndpointImpl(servicePerEndpoint) { }

    /**
     * Use `ReqRepMethodPerEndpoint.apply()` instead of this constructor.
     */
    class ReqRepMethodPerEndpointImpl protected (servicePerEndpoint: ReqRepServicePerEndpoint)
      extends MethodPerEndpoint {

        def ping(): Future[String] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Ping.Args())
          servicePerEndpoint.ping(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def checkSession(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CheckSession.Args(sessionId))
          servicePerEndpoint.checkSession(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserProfileBySessionID(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserProfileBySessionID.Args(sessionId))
          servicePerEndpoint.getUserProfileBySessionID(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserProfileByUsername(username: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserProfileByUsername.Args(username))
          servicePerEndpoint.getUserProfileByUsername(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserProfile(username: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserProfile.Args(username))
          servicePerEndpoint.getUserProfile(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getProfileByEmail(email: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetProfileByEmail.Args(email))
          servicePerEndpoint.getProfileByEmail(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def multiGetUserProfiles(usernames: Set[String] = Set[String]()): Future[xed.userprofile.domain.thrift.TMultiUserProfileResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.MultiGetUserProfiles.Args(usernames))
          servicePerEndpoint.multiGetUserProfiles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserProfiles(from: Int, size: Int): Future[xed.userprofile.domain.thrift.TUserProfileSearchResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserProfiles.Args(from, size))
          servicePerEndpoint.getUserProfiles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  class MethodIface(serviceIface: BaseServiceIface)
    extends FutureIface {
    def ping(): Future[String] =
      serviceIface.ping(self.Ping.Args())
    def checkSession(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp] =
      serviceIface.checkSession(self.CheckSession.Args(sessionId))
    def getUserProfileBySessionID(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] =
      serviceIface.getUserProfileBySessionID(self.GetUserProfileBySessionID.Args(sessionId))
    def getUserProfileByUsername(username: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp] =
      serviceIface.getUserProfileByUsername(self.GetUserProfileByUsername.Args(username))
    def getUserProfile(username: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] =
      serviceIface.getUserProfile(self.GetUserProfile.Args(username))
    def getProfileByEmail(email: String): Future[xed.userprofile.domain.thrift.TUserProfileResp] =
      serviceIface.getProfileByEmail(self.GetProfileByEmail.Args(email))
    def multiGetUserProfiles(usernames: Set[String] = Set[String]()): Future[xed.userprofile.domain.thrift.TMultiUserProfileResp] =
      serviceIface.multiGetUserProfiles(self.MultiGetUserProfiles.Args(usernames))
    def getUserProfiles(from: Int, size: Int): Future[xed.userprofile.domain.thrift.TUserProfileSearchResp] =
      serviceIface.getUserProfiles(self.GetUserProfiles.Args(from, size))
  }

  implicit object MethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.MethodPerEndpointBuilder[ServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2018-01-12")
  implicit object ThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ThriftServiceBuilder[ServicePerEndpoint, TUserProfileService[Future]] {
    def build(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  implicit object ReqRepMethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepMethodPerEndpointBuilder[ReqRepServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use ReqRepMethodPerEndpointBuilder", "2018-01-12")
  implicit object ReqRepThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepThriftServiceBuilder[ReqRepServicePerEndpoint, TUserProfileService[Future]] {
    def build(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2017-11-07")
  implicit object MethodIfaceBuilder
    extends com.twitter.finagle.thrift.MethodIfaceBuilder[ServiceIface, TUserProfileService[Future]] {
    def newMethodIface(serviceIface: ServiceIface): MethodIface =
      new MethodIface(serviceIface)
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  trait FutureIface
    extends TUserProfileService[Future] {
    
    def ping(): Future[String]
    
    def checkSession(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserAuthInfoResp]
    
    def getUserProfileBySessionID(sessionId: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp]
    
    def getUserProfileByUsername(username: String): Future[xed.userprofile.domain.thrift.TFullUserInfoResp]
    
    def getUserProfile(username: String): Future[xed.userprofile.domain.thrift.TUserProfileResp]
    
    def getProfileByEmail(email: String): Future[xed.userprofile.domain.thrift.TUserProfileResp]
    
    def multiGetUserProfiles(usernames: Set[String] = Set[String]()): Future[xed.userprofile.domain.thrift.TMultiUserProfileResp]
    
    def getUserProfiles(from: Int, size: Int): Future[xed.userprofile.domain.thrift.TUserProfileSearchResp]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      clientParam: RichClientParam)
    extends TUserProfileService$FinagleClient(service, clientParam)
    with FutureIface
    with MethodPerEndpoint {

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory = Protocols.binaryFactory(),
      serviceName: String = "TUserProfileService",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver,
      responseClassifier: ctfs.ResponseClassifier = ctfs.ResponseClassifier.Default
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats,
        responseClassifier = responseClassifier
      )
    )

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String,
      stats: com.twitter.finagle.stats.StatsReceiver
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats
      )
    )
  }

  class FinagledService(
      iface: TUserProfileService[Future],
      serverParam: RichServerParam)
    extends TUserProfileService$FinagleService(iface, serverParam) {

    @deprecated("Use com.twitter.finagle.thrift.RichServerParam", "2017-08-16")
    def this(
      iface: TUserProfileService[Future],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String = "TUserProfileService"
    ) = this(iface, RichServerParam(protocolFactory, serviceName))
  }
}
