/**
 * Generated by Scrooge
 *   version: 18.4.0
 *   rev: b64bcb47af2451b2e51a1ed1b3876f6c06c642b3
 *   built at: 20180410-144307
 */
package xed.leaderboard_mw.service

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob,
  ThriftService,
  ThriftStruct,
  ThriftStructCodec,
  ThriftStructFieldInfo,
  ThriftResponse,
  ThriftUtil,
  ToThriftService,
  ValidatingThriftStruct,
  ValidatingThriftStructCodec3
}
import com.twitter.finagle.{service => ctfs}
import com.twitter.finagle.thrift.{
  Protocols,
  RichClientParam,
  RichServerParam,
  ThriftClientRequest,
  ThriftServiceIface
}
import com.twitter.util.Future
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait TLeaderBoardMWService[+MM[_]] extends ThriftService {
  
  def ping(): MM[String]
  
  def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): MM[xed.leaderboard.domain.thrift.TLeaderBoard]
  
  def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): MM[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
  
  def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): MM[Boolean]
  
  def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): MM[Boolean]
  
  def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): MM[Boolean]
  
  def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): MM[Boolean]
  
  def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): MM[xed.leaderboard.domain.thrift.TUserPointResp]
  
  def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): MM[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
  
  def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): MM[Boolean]
  
  def delChallengeUserPoint(gameId: String, username: String): MM[Boolean]
  
  def getSocialLeaderBoard(owner: String, from: Int, to: Int): MM[xed.leaderboard.domain.thrift.TLeaderBoard]
  
  def getSocialUserRank(owner: String, username: String): MM[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
  
  def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): MM[Boolean]
  
  def addSocialFriend(owner: String, username: String): MM[Boolean]
  
  def removeSocialFriend(owner: String, username: String): MM[Boolean]
  
  def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): MM[Boolean]
  
  def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): MM[Boolean]
  
  def getSocialUserPoint(username: String): MM[xed.leaderboard.domain.thrift.TUserPointResp]
  
  def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): MM[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
  
  def delSocialUserPoint(username: String): MM[Boolean]
  
  def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): MM[Boolean]
  
  def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): MM[Boolean]
  
  def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): MM[Boolean]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object TLeaderBoardMWService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  trait ServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType]
    def getChallengeUserRank : _root_.com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType]
    def setChallengeUserPoint : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType]
    def setChallengeUserPoints : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType]
    def setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType]
    def setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType]
    def getChallengeUserPoint : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType]
    def getChallengeUserPoints : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType]
    def delChallengeUserPoints : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType]
    def delChallengeUserPoint : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType]
    def getSocialLeaderBoard : _root_.com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType]
    def getSocialUserRank : _root_.com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType]
    def setSocialFriendList : _root_.com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType]
    def addSocialFriend : _root_.com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType]
    def removeSocialFriend : _root_.com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType]
    def setSocialUserPoint : _root_.com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType]
    def setSocialUserPoints : _root_.com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType]
    def getSocialUserPoint : _root_.com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType]
    def getSocialUserPoints : _root_.com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType]
    def delSocialUserPoint : _root_.com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType]
    def delSocialUserPoints : _root_.com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType]
    def setUserProfile : _root_.com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType]
    def setUserProfiles : _root_.com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]

    def withPing(ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]): ServicePerEndpoint = this

    def withGetChallengeLeaderBoard(getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType]): ServicePerEndpoint = this

    def withGetChallengeUserRank(getChallengeUserRank : _root_.com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType]): ServicePerEndpoint = this

    def withSetChallengeUserPoint(setChallengeUserPoint : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType]): ServicePerEndpoint = this

    def withSetChallengeUserPoints(setChallengeUserPoints : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType]): ServicePerEndpoint = this

    def withSetChallengeUserPointIfHighest(setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType]): ServicePerEndpoint = this

    def withSetChallengeUserPointsIfHighest(setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType]): ServicePerEndpoint = this

    def withGetChallengeUserPoint(getChallengeUserPoint : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType]): ServicePerEndpoint = this

    def withGetChallengeUserPoints(getChallengeUserPoints : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType]): ServicePerEndpoint = this

    def withDelChallengeUserPoints(delChallengeUserPoints : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType]): ServicePerEndpoint = this

    def withDelChallengeUserPoint(delChallengeUserPoint : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType]): ServicePerEndpoint = this

    def withGetSocialLeaderBoard(getSocialLeaderBoard : _root_.com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType]): ServicePerEndpoint = this

    def withGetSocialUserRank(getSocialUserRank : _root_.com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType]): ServicePerEndpoint = this

    def withSetSocialFriendList(setSocialFriendList : _root_.com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType]): ServicePerEndpoint = this

    def withAddSocialFriend(addSocialFriend : _root_.com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType]): ServicePerEndpoint = this

    def withRemoveSocialFriend(removeSocialFriend : _root_.com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType]): ServicePerEndpoint = this

    def withSetSocialUserPoint(setSocialUserPoint : _root_.com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType]): ServicePerEndpoint = this

    def withSetSocialUserPoints(setSocialUserPoints : _root_.com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType]): ServicePerEndpoint = this

    def withGetSocialUserPoint(getSocialUserPoint : _root_.com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType]): ServicePerEndpoint = this

    def withGetSocialUserPoints(getSocialUserPoints : _root_.com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType]): ServicePerEndpoint = this

    def withDelSocialUserPoint(delSocialUserPoint : _root_.com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType]): ServicePerEndpoint = this

    def withDelSocialUserPoints(delSocialUserPoints : _root_.com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType]): ServicePerEndpoint = this

    def withSetUserProfile(setUserProfile : _root_.com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType]): ServicePerEndpoint = this

    def withSetUserProfiles(setUserProfiles : _root_.com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]): ServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = MethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  trait ReqRepServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.service.Filterable[ReqRepServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
    def getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeLeaderBoard.SuccessType]]
    def getChallengeUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserRank.SuccessType]]
    def setChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoint.SuccessType]]
    def setChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoints.SuccessType]]
    def setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointIfHighest.SuccessType]]
    def setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointsIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointsIfHighest.SuccessType]]
    def getChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoint.SuccessType]]
    def getChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoints.SuccessType]]
    def delChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoints.SuccessType]]
    def delChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoint.SuccessType]]
    def getSocialLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetSocialLeaderBoard.SuccessType]]
    def getSocialUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserRank.SuccessType]]
    def setSocialFriendList : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialFriendList.Args], _root_.com.twitter.scrooge.Response[self.SetSocialFriendList.SuccessType]]
    def addSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AddSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.AddSocialFriend.SuccessType]]
    def removeSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RemoveSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.RemoveSocialFriend.SuccessType]]
    def setSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoint.SuccessType]]
    def setSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoints.SuccessType]]
    def getSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoint.SuccessType]]
    def getSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoints.SuccessType]]
    def delSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoint.SuccessType]]
    def delSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoints.SuccessType]]
    def setUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfile.SuccessType]]
    def setUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfiles.SuccessType]]

    def withPing(ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetChallengeLeaderBoard(getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeLeaderBoard.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetChallengeUserRank(getChallengeUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserRank.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetChallengeUserPoint(setChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetChallengeUserPoints(setChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetChallengeUserPointIfHighest(setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointIfHighest.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetChallengeUserPointsIfHighest(setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointsIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointsIfHighest.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetChallengeUserPoint(getChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetChallengeUserPoints(getChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDelChallengeUserPoints(delChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDelChallengeUserPoint(delChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetSocialLeaderBoard(getSocialLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetSocialLeaderBoard.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetSocialUserRank(getSocialUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserRank.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetSocialFriendList(setSocialFriendList : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialFriendList.Args], _root_.com.twitter.scrooge.Response[self.SetSocialFriendList.SuccessType]]): ReqRepServicePerEndpoint = this

    def withAddSocialFriend(addSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AddSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.AddSocialFriend.SuccessType]]): ReqRepServicePerEndpoint = this

    def withRemoveSocialFriend(removeSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RemoveSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.RemoveSocialFriend.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetSocialUserPoint(setSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetSocialUserPoints(setSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetSocialUserPoint(getSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetSocialUserPoints(getSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDelSocialUserPoint(delSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoint.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDelSocialUserPoints(delSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoints.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetUserProfile(setUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfile.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSetUserProfiles(setUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfiles.SuccessType]]): ReqRepServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = ReqRepMethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  trait BaseServiceIface extends ToThriftService {
    def ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def getChallengeLeaderBoard : com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType]
    def getChallengeUserRank : com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType]
    def setChallengeUserPoint : com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType]
    def setChallengeUserPoints : com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType]
    def setChallengeUserPointIfHighest : com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType]
    def setChallengeUserPointsIfHighest : com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType]
    def getChallengeUserPoint : com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType]
    def getChallengeUserPoints : com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType]
    def delChallengeUserPoints : com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType]
    def delChallengeUserPoint : com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType]
    def getSocialLeaderBoard : com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType]
    def getSocialUserRank : com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType]
    def setSocialFriendList : com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType]
    def addSocialFriend : com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType]
    def removeSocialFriend : com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType]
    def setSocialUserPoint : com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType]
    def setSocialUserPoints : com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType]
    def getSocialUserPoint : com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType]
    def getSocialUserPoints : com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType]
    def delSocialUserPoint : com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType]
    def delSocialUserPoints : com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType]
    def setUserProfile : com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType]
    def setUserProfiles : com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]

    def toThriftService: ThriftService = new MethodIface(this)
  }

  object ServicePerEndpoint {

    def apply(
      ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType],
      getChallengeUserRank : _root_.com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType],
      setChallengeUserPoint : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType],
      setChallengeUserPoints : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType],
      setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType],
      setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType],
      getChallengeUserPoint : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType],
      getChallengeUserPoints : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType],
      delChallengeUserPoints : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType],
      delChallengeUserPoint : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType],
      getSocialLeaderBoard : _root_.com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType],
      getSocialUserRank : _root_.com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType],
      setSocialFriendList : _root_.com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType],
      addSocialFriend : _root_.com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType],
      removeSocialFriend : _root_.com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType],
      setSocialUserPoint : _root_.com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType],
      setSocialUserPoints : _root_.com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType],
      getSocialUserPoint : _root_.com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType],
      getSocialUserPoints : _root_.com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType],
      delSocialUserPoint : _root_.com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType],
      delSocialUserPoints : _root_.com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType],
      setUserProfile : _root_.com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType],
      setUserProfiles : _root_.com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]
    ): ServicePerEndpoint = new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

    private final class ServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      override val getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType],
      override val getChallengeUserRank : _root_.com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType],
      override val setChallengeUserPoint : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType],
      override val setChallengeUserPoints : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType],
      override val setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType],
      override val setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType],
      override val getChallengeUserPoint : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType],
      override val getChallengeUserPoints : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType],
      override val delChallengeUserPoints : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType],
      override val delChallengeUserPoint : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType],
      override val getSocialLeaderBoard : _root_.com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType],
      override val getSocialUserRank : _root_.com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType],
      override val setSocialFriendList : _root_.com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType],
      override val addSocialFriend : _root_.com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType],
      override val removeSocialFriend : _root_.com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType],
      override val setSocialUserPoint : _root_.com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType],
      override val setSocialUserPoints : _root_.com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType],
      override val getSocialUserPoint : _root_.com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType],
      override val getSocialUserPoints : _root_.com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType],
      override val delSocialUserPoint : _root_.com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType],
      override val delSocialUserPoints : _root_.com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType],
      override val setUserProfile : _root_.com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType],
      override val setUserProfiles : _root_.com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]
    ) extends ServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetChallengeLeaderBoard(
        getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetChallengeUserRank(
        getChallengeUserRank : _root_.com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetChallengeUserPoint(
        setChallengeUserPoint : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetChallengeUserPoints(
        setChallengeUserPoints : _root_.com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetChallengeUserPointIfHighest(
        setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetChallengeUserPointsIfHighest(
        setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetChallengeUserPoint(
        getChallengeUserPoint : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetChallengeUserPoints(
        getChallengeUserPoints : _root_.com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withDelChallengeUserPoints(
        delChallengeUserPoints : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withDelChallengeUserPoint(
        delChallengeUserPoint : _root_.com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetSocialLeaderBoard(
        getSocialLeaderBoard : _root_.com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetSocialUserRank(
        getSocialUserRank : _root_.com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetSocialFriendList(
        setSocialFriendList : _root_.com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withAddSocialFriend(
        addSocialFriend : _root_.com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withRemoveSocialFriend(
        removeSocialFriend : _root_.com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetSocialUserPoint(
        setSocialUserPoint : _root_.com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetSocialUserPoints(
        setSocialUserPoints : _root_.com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetSocialUserPoint(
        getSocialUserPoint : _root_.com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withGetSocialUserPoints(
        getSocialUserPoints : _root_.com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withDelSocialUserPoint(
        delSocialUserPoint : _root_.com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withDelSocialUserPoints(
        delSocialUserPoints : _root_.com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetUserProfile(
        setUserProfile : _root_.com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def withSetUserProfiles(
        setUserProfiles : _root_.com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint =
        new ServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          getChallengeLeaderBoard = filter.toFilter.andThen(getChallengeLeaderBoard),
          getChallengeUserRank = filter.toFilter.andThen(getChallengeUserRank),
          setChallengeUserPoint = filter.toFilter.andThen(setChallengeUserPoint),
          setChallengeUserPoints = filter.toFilter.andThen(setChallengeUserPoints),
          setChallengeUserPointIfHighest = filter.toFilter.andThen(setChallengeUserPointIfHighest),
          setChallengeUserPointsIfHighest = filter.toFilter.andThen(setChallengeUserPointsIfHighest),
          getChallengeUserPoint = filter.toFilter.andThen(getChallengeUserPoint),
          getChallengeUserPoints = filter.toFilter.andThen(getChallengeUserPoints),
          delChallengeUserPoints = filter.toFilter.andThen(delChallengeUserPoints),
          delChallengeUserPoint = filter.toFilter.andThen(delChallengeUserPoint),
          getSocialLeaderBoard = filter.toFilter.andThen(getSocialLeaderBoard),
          getSocialUserRank = filter.toFilter.andThen(getSocialUserRank),
          setSocialFriendList = filter.toFilter.andThen(setSocialFriendList),
          addSocialFriend = filter.toFilter.andThen(addSocialFriend),
          removeSocialFriend = filter.toFilter.andThen(removeSocialFriend),
          setSocialUserPoint = filter.toFilter.andThen(setSocialUserPoint),
          setSocialUserPoints = filter.toFilter.andThen(setSocialUserPoints),
          getSocialUserPoint = filter.toFilter.andThen(getSocialUserPoint),
          getSocialUserPoints = filter.toFilter.andThen(getSocialUserPoints),
          delSocialUserPoint = filter.toFilter.andThen(delSocialUserPoint),
          delSocialUserPoints = filter.toFilter.andThen(delSocialUserPoints),
          setUserProfile = filter.toFilter.andThen(setUserProfile),
          setUserProfiles = filter.toFilter.andThen(setUserProfiles)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.getChallengeLeaderBoard,
          this.getChallengeUserRank,
          this.setChallengeUserPoint,
          this.setChallengeUserPoints,
          this.setChallengeUserPointIfHighest,
          this.setChallengeUserPointsIfHighest,
          this.getChallengeUserPoint,
          this.getChallengeUserPoints,
          this.delChallengeUserPoints,
          this.delChallengeUserPoint,
          this.getSocialLeaderBoard,
          this.getSocialUserRank,
          this.setSocialFriendList,
          this.addSocialFriend,
          this.removeSocialFriend,
          this.setSocialUserPoint,
          this.setSocialUserPoints,
          this.getSocialUserPoint,
          this.getSocialUserPoints,
          this.delSocialUserPoint,
          this.delSocialUserPoints,
          this.setUserProfile,
          this.setUserProfiles
        )
    }
  }

  object ReqRepServicePerEndpoint {

    def apply(
      ping :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      getChallengeLeaderBoard :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeLeaderBoard.SuccessType]],
      getChallengeUserRank :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserRank.SuccessType]],
      setChallengeUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoint.SuccessType]],
      setChallengeUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoints.SuccessType]],
      setChallengeUserPointIfHighest :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPointIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointIfHighest.SuccessType]],
      setChallengeUserPointsIfHighest :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPointsIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointsIfHighest.SuccessType]],
      getChallengeUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoint.SuccessType]],
      getChallengeUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoints.SuccessType]],
      delChallengeUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoints.SuccessType]],
      delChallengeUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoint.SuccessType]],
      getSocialLeaderBoard :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetSocialLeaderBoard.SuccessType]],
      getSocialUserRank :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserRank.SuccessType]],
      setSocialFriendList :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialFriendList.Args], _root_.com.twitter.scrooge.Response[self.SetSocialFriendList.SuccessType]],
      addSocialFriend :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.AddSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.AddSocialFriend.SuccessType]],
      removeSocialFriend :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RemoveSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.RemoveSocialFriend.SuccessType]],
      setSocialUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoint.SuccessType]],
      setSocialUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoints.SuccessType]],
      getSocialUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoint.SuccessType]],
      getSocialUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoints.SuccessType]],
      delSocialUserPoint :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoint.SuccessType]],
      delSocialUserPoints :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoints.SuccessType]],
      setUserProfile :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfile.SuccessType]],
      setUserProfiles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfiles.SuccessType]]
    ): ReqRepServicePerEndpoint =
      new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

    private final class ReqRepServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      override val getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeLeaderBoard.SuccessType]],
      override val getChallengeUserRank : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserRank.SuccessType]],
      override val setChallengeUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoint.SuccessType]],
      override val setChallengeUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoints.SuccessType]],
      override val setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPointIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointIfHighest.SuccessType]],
      override val setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetChallengeUserPointsIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointsIfHighest.SuccessType]],
      override val getChallengeUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoint.SuccessType]],
      override val getChallengeUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoints.SuccessType]],
      override val delChallengeUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoints.SuccessType]],
      override val delChallengeUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoint.SuccessType]],
      override val getSocialLeaderBoard : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetSocialLeaderBoard.SuccessType]],
      override val getSocialUserRank : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserRank.SuccessType]],
      override val setSocialFriendList : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialFriendList.Args], _root_.com.twitter.scrooge.Response[self.SetSocialFriendList.SuccessType]],
      override val addSocialFriend : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.AddSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.AddSocialFriend.SuccessType]],
      override val removeSocialFriend : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RemoveSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.RemoveSocialFriend.SuccessType]],
      override val setSocialUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoint.SuccessType]],
      override val setSocialUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoints.SuccessType]],
      override val getSocialUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoint.SuccessType]],
      override val getSocialUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoints.SuccessType]],
      override val delSocialUserPoint : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoint.SuccessType]],
      override val delSocialUserPoints : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DelSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoints.SuccessType]],
      override val setUserProfile : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfile.SuccessType]],
      override val setUserProfiles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfiles.SuccessType]]
    ) extends ReqRepServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetChallengeLeaderBoard(
        getChallengeLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeLeaderBoard.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetChallengeUserRank(
        getChallengeUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserRank.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetChallengeUserPoint(
        setChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetChallengeUserPoints(
        setChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetChallengeUserPointIfHighest(
        setChallengeUserPointIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointIfHighest.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetChallengeUserPointsIfHighest(
        setChallengeUserPointsIfHighest : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetChallengeUserPointsIfHighest.Args], _root_.com.twitter.scrooge.Response[self.SetChallengeUserPointsIfHighest.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetChallengeUserPoint(
        getChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetChallengeUserPoints(
        getChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetChallengeUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withDelChallengeUserPoints(
        delChallengeUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withDelChallengeUserPoint(
        delChallengeUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelChallengeUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelChallengeUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetSocialLeaderBoard(
        getSocialLeaderBoard : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialLeaderBoard.Args], _root_.com.twitter.scrooge.Response[self.GetSocialLeaderBoard.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetSocialUserRank(
        getSocialUserRank : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserRank.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserRank.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetSocialFriendList(
        setSocialFriendList : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialFriendList.Args], _root_.com.twitter.scrooge.Response[self.SetSocialFriendList.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withAddSocialFriend(
        addSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AddSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.AddSocialFriend.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withRemoveSocialFriend(
        removeSocialFriend : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RemoveSocialFriend.Args], _root_.com.twitter.scrooge.Response[self.RemoveSocialFriend.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetSocialUserPoint(
        setSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetSocialUserPoints(
        setSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.SetSocialUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetSocialUserPoint(
        getSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withGetSocialUserPoints(
        getSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.GetSocialUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withDelSocialUserPoint(
        delSocialUserPoint : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoint.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoint.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withDelSocialUserPoints(
        delSocialUserPoints : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DelSocialUserPoints.Args], _root_.com.twitter.scrooge.Response[self.DelSocialUserPoints.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetUserProfile(
        setUserProfile : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfile.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfile.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)
      override def withSetUserProfiles(
        setUserProfiles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SetUserProfiles.Args], _root_.com.twitter.scrooge.Response[self.SetUserProfiles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, getChallengeLeaderBoard, getChallengeUserRank, setChallengeUserPoint, setChallengeUserPoints, setChallengeUserPointIfHighest, setChallengeUserPointsIfHighest, getChallengeUserPoint, getChallengeUserPoints, delChallengeUserPoints, delChallengeUserPoint, getSocialLeaderBoard, getSocialUserRank, setSocialFriendList, addSocialFriend, removeSocialFriend, setSocialUserPoint, setSocialUserPoints, getSocialUserPoint, getSocialUserPoints, delSocialUserPoint, delSocialUserPoints, setUserProfile, setUserProfiles)

      override def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          getChallengeLeaderBoard = filter.toFilter.andThen(getChallengeLeaderBoard),
          getChallengeUserRank = filter.toFilter.andThen(getChallengeUserRank),
          setChallengeUserPoint = filter.toFilter.andThen(setChallengeUserPoint),
          setChallengeUserPoints = filter.toFilter.andThen(setChallengeUserPoints),
          setChallengeUserPointIfHighest = filter.toFilter.andThen(setChallengeUserPointIfHighest),
          setChallengeUserPointsIfHighest = filter.toFilter.andThen(setChallengeUserPointsIfHighest),
          getChallengeUserPoint = filter.toFilter.andThen(getChallengeUserPoint),
          getChallengeUserPoints = filter.toFilter.andThen(getChallengeUserPoints),
          delChallengeUserPoints = filter.toFilter.andThen(delChallengeUserPoints),
          delChallengeUserPoint = filter.toFilter.andThen(delChallengeUserPoint),
          getSocialLeaderBoard = filter.toFilter.andThen(getSocialLeaderBoard),
          getSocialUserRank = filter.toFilter.andThen(getSocialUserRank),
          setSocialFriendList = filter.toFilter.andThen(setSocialFriendList),
          addSocialFriend = filter.toFilter.andThen(addSocialFriend),
          removeSocialFriend = filter.toFilter.andThen(removeSocialFriend),
          setSocialUserPoint = filter.toFilter.andThen(setSocialUserPoint),
          setSocialUserPoints = filter.toFilter.andThen(setSocialUserPoints),
          getSocialUserPoint = filter.toFilter.andThen(getSocialUserPoint),
          getSocialUserPoints = filter.toFilter.andThen(getSocialUserPoints),
          delSocialUserPoint = filter.toFilter.andThen(delSocialUserPoint),
          delSocialUserPoints = filter.toFilter.andThen(delSocialUserPoints),
          setUserProfile = filter.toFilter.andThen(setUserProfile),
          setUserProfiles = filter.toFilter.andThen(setUserProfiles)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.getChallengeLeaderBoard,
          this.getChallengeUserRank,
          this.setChallengeUserPoint,
          this.setChallengeUserPoints,
          this.setChallengeUserPointIfHighest,
          this.setChallengeUserPointsIfHighest,
          this.getChallengeUserPoint,
          this.getChallengeUserPoints,
          this.delChallengeUserPoints,
          this.delChallengeUserPoint,
          this.getSocialLeaderBoard,
          this.getSocialUserRank,
          this.setSocialFriendList,
          this.addSocialFriend,
          this.removeSocialFriend,
          this.setSocialUserPoint,
          this.setSocialUserPoints,
          this.getSocialUserPoint,
          this.getSocialUserPoints,
          this.delSocialUserPoint,
          this.delSocialUserPoints,
          this.setUserProfile,
          this.setUserProfiles
        )
    }
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  case class ServiceIface(
    ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
    getChallengeLeaderBoard : com.twitter.finagle.Service[self.GetChallengeLeaderBoard.Args, self.GetChallengeLeaderBoard.SuccessType],
    getChallengeUserRank : com.twitter.finagle.Service[self.GetChallengeUserRank.Args, self.GetChallengeUserRank.SuccessType],
    setChallengeUserPoint : com.twitter.finagle.Service[self.SetChallengeUserPoint.Args, self.SetChallengeUserPoint.SuccessType],
    setChallengeUserPoints : com.twitter.finagle.Service[self.SetChallengeUserPoints.Args, self.SetChallengeUserPoints.SuccessType],
    setChallengeUserPointIfHighest : com.twitter.finagle.Service[self.SetChallengeUserPointIfHighest.Args, self.SetChallengeUserPointIfHighest.SuccessType],
    setChallengeUserPointsIfHighest : com.twitter.finagle.Service[self.SetChallengeUserPointsIfHighest.Args, self.SetChallengeUserPointsIfHighest.SuccessType],
    getChallengeUserPoint : com.twitter.finagle.Service[self.GetChallengeUserPoint.Args, self.GetChallengeUserPoint.SuccessType],
    getChallengeUserPoints : com.twitter.finagle.Service[self.GetChallengeUserPoints.Args, self.GetChallengeUserPoints.SuccessType],
    delChallengeUserPoints : com.twitter.finagle.Service[self.DelChallengeUserPoints.Args, self.DelChallengeUserPoints.SuccessType],
    delChallengeUserPoint : com.twitter.finagle.Service[self.DelChallengeUserPoint.Args, self.DelChallengeUserPoint.SuccessType],
    getSocialLeaderBoard : com.twitter.finagle.Service[self.GetSocialLeaderBoard.Args, self.GetSocialLeaderBoard.SuccessType],
    getSocialUserRank : com.twitter.finagle.Service[self.GetSocialUserRank.Args, self.GetSocialUserRank.SuccessType],
    setSocialFriendList : com.twitter.finagle.Service[self.SetSocialFriendList.Args, self.SetSocialFriendList.SuccessType],
    addSocialFriend : com.twitter.finagle.Service[self.AddSocialFriend.Args, self.AddSocialFriend.SuccessType],
    removeSocialFriend : com.twitter.finagle.Service[self.RemoveSocialFriend.Args, self.RemoveSocialFriend.SuccessType],
    setSocialUserPoint : com.twitter.finagle.Service[self.SetSocialUserPoint.Args, self.SetSocialUserPoint.SuccessType],
    setSocialUserPoints : com.twitter.finagle.Service[self.SetSocialUserPoints.Args, self.SetSocialUserPoints.SuccessType],
    getSocialUserPoint : com.twitter.finagle.Service[self.GetSocialUserPoint.Args, self.GetSocialUserPoint.SuccessType],
    getSocialUserPoints : com.twitter.finagle.Service[self.GetSocialUserPoints.Args, self.GetSocialUserPoints.SuccessType],
    delSocialUserPoint : com.twitter.finagle.Service[self.DelSocialUserPoint.Args, self.DelSocialUserPoint.SuccessType],
    delSocialUserPoints : com.twitter.finagle.Service[self.DelSocialUserPoints.Args, self.DelSocialUserPoints.SuccessType],
    setUserProfile : com.twitter.finagle.Service[self.SetUserProfile.Args, self.SetUserProfile.SuccessType],
    setUserProfiles : com.twitter.finagle.Service[self.SetUserProfiles.Args, self.SetUserProfiles.SuccessType]
  ) extends BaseServiceIface
    with com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServiceIface] {

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServiceIface` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ServiceIface =
      copy(
        ping = filter.toFilter.andThen(ping),
        getChallengeLeaderBoard = filter.toFilter.andThen(getChallengeLeaderBoard),
        getChallengeUserRank = filter.toFilter.andThen(getChallengeUserRank),
        setChallengeUserPoint = filter.toFilter.andThen(setChallengeUserPoint),
        setChallengeUserPoints = filter.toFilter.andThen(setChallengeUserPoints),
        setChallengeUserPointIfHighest = filter.toFilter.andThen(setChallengeUserPointIfHighest),
        setChallengeUserPointsIfHighest = filter.toFilter.andThen(setChallengeUserPointsIfHighest),
        getChallengeUserPoint = filter.toFilter.andThen(getChallengeUserPoint),
        getChallengeUserPoints = filter.toFilter.andThen(getChallengeUserPoints),
        delChallengeUserPoints = filter.toFilter.andThen(delChallengeUserPoints),
        delChallengeUserPoint = filter.toFilter.andThen(delChallengeUserPoint),
        getSocialLeaderBoard = filter.toFilter.andThen(getSocialLeaderBoard),
        getSocialUserRank = filter.toFilter.andThen(getSocialUserRank),
        setSocialFriendList = filter.toFilter.andThen(setSocialFriendList),
        addSocialFriend = filter.toFilter.andThen(addSocialFriend),
        removeSocialFriend = filter.toFilter.andThen(removeSocialFriend),
        setSocialUserPoint = filter.toFilter.andThen(setSocialUserPoint),
        setSocialUserPoints = filter.toFilter.andThen(setSocialUserPoints),
        getSocialUserPoint = filter.toFilter.andThen(getSocialUserPoint),
        getSocialUserPoints = filter.toFilter.andThen(getSocialUserPoints),
        delSocialUserPoint = filter.toFilter.andThen(delSocialUserPoint),
        delSocialUserPoints = filter.toFilter.andThen(delSocialUserPoints),
        setUserProfile = filter.toFilter.andThen(setUserProfile),
        setUserProfiles = filter.toFilter.andThen(setUserProfiles)
      )
  }

  implicit object ServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ServicePerEndpointBuilder[ServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServicePerEndpoint =
        ServicePerEndpoint(
          ping = ThriftServiceIface(self.Ping, thriftService, clientParam),
          getChallengeLeaderBoard = ThriftServiceIface(self.GetChallengeLeaderBoard, thriftService, clientParam),
          getChallengeUserRank = ThriftServiceIface(self.GetChallengeUserRank, thriftService, clientParam),
          setChallengeUserPoint = ThriftServiceIface(self.SetChallengeUserPoint, thriftService, clientParam),
          setChallengeUserPoints = ThriftServiceIface(self.SetChallengeUserPoints, thriftService, clientParam),
          setChallengeUserPointIfHighest = ThriftServiceIface(self.SetChallengeUserPointIfHighest, thriftService, clientParam),
          setChallengeUserPointsIfHighest = ThriftServiceIface(self.SetChallengeUserPointsIfHighest, thriftService, clientParam),
          getChallengeUserPoint = ThriftServiceIface(self.GetChallengeUserPoint, thriftService, clientParam),
          getChallengeUserPoints = ThriftServiceIface(self.GetChallengeUserPoints, thriftService, clientParam),
          delChallengeUserPoints = ThriftServiceIface(self.DelChallengeUserPoints, thriftService, clientParam),
          delChallengeUserPoint = ThriftServiceIface(self.DelChallengeUserPoint, thriftService, clientParam),
          getSocialLeaderBoard = ThriftServiceIface(self.GetSocialLeaderBoard, thriftService, clientParam),
          getSocialUserRank = ThriftServiceIface(self.GetSocialUserRank, thriftService, clientParam),
          setSocialFriendList = ThriftServiceIface(self.SetSocialFriendList, thriftService, clientParam),
          addSocialFriend = ThriftServiceIface(self.AddSocialFriend, thriftService, clientParam),
          removeSocialFriend = ThriftServiceIface(self.RemoveSocialFriend, thriftService, clientParam),
          setSocialUserPoint = ThriftServiceIface(self.SetSocialUserPoint, thriftService, clientParam),
          setSocialUserPoints = ThriftServiceIface(self.SetSocialUserPoints, thriftService, clientParam),
          getSocialUserPoint = ThriftServiceIface(self.GetSocialUserPoint, thriftService, clientParam),
          getSocialUserPoints = ThriftServiceIface(self.GetSocialUserPoints, thriftService, clientParam),
          delSocialUserPoint = ThriftServiceIface(self.DelSocialUserPoint, thriftService, clientParam),
          delSocialUserPoints = ThriftServiceIface(self.DelSocialUserPoints, thriftService, clientParam),
          setUserProfile = ThriftServiceIface(self.SetUserProfile, thriftService, clientParam),
          setUserProfiles = ThriftServiceIface(self.SetUserProfiles, thriftService, clientParam)
        )
  }

  implicit object ReqRepServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepServicePerEndpointBuilder[ReqRepServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ReqRepServicePerEndpoint =
        ReqRepServicePerEndpoint(
          ping = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Ping, thriftService, clientParam),
          getChallengeLeaderBoard = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetChallengeLeaderBoard, thriftService, clientParam),
          getChallengeUserRank = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetChallengeUserRank, thriftService, clientParam),
          setChallengeUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetChallengeUserPoint, thriftService, clientParam),
          setChallengeUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetChallengeUserPoints, thriftService, clientParam),
          setChallengeUserPointIfHighest = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetChallengeUserPointIfHighest, thriftService, clientParam),
          setChallengeUserPointsIfHighest = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetChallengeUserPointsIfHighest, thriftService, clientParam),
          getChallengeUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetChallengeUserPoint, thriftService, clientParam),
          getChallengeUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetChallengeUserPoints, thriftService, clientParam),
          delChallengeUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DelChallengeUserPoints, thriftService, clientParam),
          delChallengeUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DelChallengeUserPoint, thriftService, clientParam),
          getSocialLeaderBoard = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetSocialLeaderBoard, thriftService, clientParam),
          getSocialUserRank = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetSocialUserRank, thriftService, clientParam),
          setSocialFriendList = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetSocialFriendList, thriftService, clientParam),
          addSocialFriend = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.AddSocialFriend, thriftService, clientParam),
          removeSocialFriend = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.RemoveSocialFriend, thriftService, clientParam),
          setSocialUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetSocialUserPoint, thriftService, clientParam),
          setSocialUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetSocialUserPoints, thriftService, clientParam),
          getSocialUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetSocialUserPoint, thriftService, clientParam),
          getSocialUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetSocialUserPoints, thriftService, clientParam),
          delSocialUserPoint = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DelSocialUserPoint, thriftService, clientParam),
          delSocialUserPoints = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DelSocialUserPoints, thriftService, clientParam),
          setUserProfile = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetUserProfile, thriftService, clientParam),
          setUserProfiles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SetUserProfiles, thriftService, clientParam)
        )
  }

  @deprecated("Use ServicePerEndpointBuilder", "2017-11-07")
  implicit object ServiceIfaceBuilder
    extends com.twitter.finagle.thrift.ServiceIfaceBuilder[ServiceIface] {
      def newServiceIface(
        binaryService: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServiceIface =
        ServiceIface(
          ping = ThriftServiceIface(self.Ping, binaryService, clientParam),
          getChallengeLeaderBoard = ThriftServiceIface(self.GetChallengeLeaderBoard, binaryService, clientParam),
          getChallengeUserRank = ThriftServiceIface(self.GetChallengeUserRank, binaryService, clientParam),
          setChallengeUserPoint = ThriftServiceIface(self.SetChallengeUserPoint, binaryService, clientParam),
          setChallengeUserPoints = ThriftServiceIface(self.SetChallengeUserPoints, binaryService, clientParam),
          setChallengeUserPointIfHighest = ThriftServiceIface(self.SetChallengeUserPointIfHighest, binaryService, clientParam),
          setChallengeUserPointsIfHighest = ThriftServiceIface(self.SetChallengeUserPointsIfHighest, binaryService, clientParam),
          getChallengeUserPoint = ThriftServiceIface(self.GetChallengeUserPoint, binaryService, clientParam),
          getChallengeUserPoints = ThriftServiceIface(self.GetChallengeUserPoints, binaryService, clientParam),
          delChallengeUserPoints = ThriftServiceIface(self.DelChallengeUserPoints, binaryService, clientParam),
          delChallengeUserPoint = ThriftServiceIface(self.DelChallengeUserPoint, binaryService, clientParam),
          getSocialLeaderBoard = ThriftServiceIface(self.GetSocialLeaderBoard, binaryService, clientParam),
          getSocialUserRank = ThriftServiceIface(self.GetSocialUserRank, binaryService, clientParam),
          setSocialFriendList = ThriftServiceIface(self.SetSocialFriendList, binaryService, clientParam),
          addSocialFriend = ThriftServiceIface(self.AddSocialFriend, binaryService, clientParam),
          removeSocialFriend = ThriftServiceIface(self.RemoveSocialFriend, binaryService, clientParam),
          setSocialUserPoint = ThriftServiceIface(self.SetSocialUserPoint, binaryService, clientParam),
          setSocialUserPoints = ThriftServiceIface(self.SetSocialUserPoints, binaryService, clientParam),
          getSocialUserPoint = ThriftServiceIface(self.GetSocialUserPoint, binaryService, clientParam),
          getSocialUserPoints = ThriftServiceIface(self.GetSocialUserPoints, binaryService, clientParam),
          delSocialUserPoint = ThriftServiceIface(self.DelSocialUserPoint, binaryService, clientParam),
          delSocialUserPoints = ThriftServiceIface(self.DelSocialUserPoints, binaryService, clientParam),
          setUserProfile = ThriftServiceIface(self.SetUserProfile, binaryService, clientParam),
          setUserProfiles = ThriftServiceIface(self.SetUserProfiles, binaryService, clientParam)
        )
  }

  object Ping extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_result")
      val SuccessField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[String]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product1[Option[String]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[String]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[String]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "ping"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val ping$args = Ping.Args
  type ping$args = Ping.Args

  val ping$result = Ping.Result
  type ping$result = Ping.Result

  object GetChallengeLeaderBoard extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeLeaderBoard_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val MyUsernameField = new TField("myUsername", TType.STRING, 2)
      val MyUsernameFieldManifest = implicitly[Manifest[String]]
      val FromField = new TField("from", TType.I32, 3)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val ToField = new TField("to", TType.I32, 4)
      val ToFieldManifest = implicitly[Manifest[Int]]
      val OnlyFriendFromSocialField = new TField("onlyFriendFromSocial", TType.BOOL, 5)
      val OnlyFriendFromSocialFieldManifest = implicitly[Manifest[Boolean]]
      val LeaderboardTypeField = new TField("leaderboardType", TType.ENUM, 6)
      val LeaderboardTypeFieldI32 = new TField("leaderboardType", TType.I32, 6)
      val LeaderboardTypeFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardType]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          MyUsernameField,
          false,
          true,
          MyUsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ToField,
          false,
          true,
          ToFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          OnlyFriendFromSocialField,
          false,
          true,
          OnlyFriendFromSocialFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          LeaderboardTypeField,
          true,
          false,
          LeaderboardTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.myUsername == null) throw new TProtocolException("Required field myUsername cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.myUsername == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.myUsername)
        buf ++= validateField(item.from)
        buf ++= validateField(item.to)
        buf ++= validateField(item.onlyFriendFromSocial)
        buf ++= validateField(item.leaderboardType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          myUsername =
            {
              val field = original.myUsername
              field
            },
          from =
            {
              val field = original.from
              field
            },
          to =
            {
              val field = original.to
              field
            },
          onlyFriendFromSocial =
            {
              val field = original.onlyFriendFromSocial
              field
            },
          leaderboardType =
            {
              val field = original.leaderboardType
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var myUsername: String = null
        var _got_myUsername = false
        var from: Int = 0
        var _got_from = false
        var to: Int = 0
        var _got_to = false
        var onlyFriendFromSocial: Boolean = false
        var _got_onlyFriendFromSocial = false
        var leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    myUsername = readMyUsernameValue(_iprot)
                    _got_myUsername = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'myUsername' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.I32 =>
                    to = readToValue(_iprot)
                    _got_to = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'to' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 5 =>
                _field.`type` match {
                  case TType.BOOL =>
                    onlyFriendFromSocial = readOnlyFriendFromSocialValue(_iprot)
                    _got_onlyFriendFromSocial = true
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'onlyFriendFromSocial' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 6 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    leaderboardType = _root_.scala.Some(readLeaderboardTypeValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'leaderboardType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_myUsername) throw new TProtocolException("Required field 'myUsername' was not found in serialized data for struct Args")
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_to) throw new TProtocolException("Required field 'to' was not found in serialized data for struct Args")
        if (!_got_onlyFriendFromSocial) throw new TProtocolException("Required field 'onlyFriendFromSocial' was not found in serialized data for struct Args")
        new Args(
          gameId,
          myUsername,
          from,
          to,
          onlyFriendFromSocial,
          leaderboardType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        myUsername: String,
        from: Int,
        to: Int,
        onlyFriendFromSocial: Boolean,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ): Args =
        new Args(
          gameId,
          myUsername,
          from,
          to,
          onlyFriendFromSocial,
          leaderboardType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple6[String, String, Int, Int, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readMyUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeMyUsernameField(myUsername_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MyUsernameField)
        writeMyUsernameValue(myUsername_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMyUsernameValue(myUsername_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(myUsername_item)
      }
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readToValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeToField(to_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ToField)
        writeToValue(to_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeToValue(to_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(to_item)
      }
    
      @inline private[service] def readOnlyFriendFromSocialValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeOnlyFriendFromSocialField(onlyFriendFromSocial_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OnlyFriendFromSocialField)
        writeOnlyFriendFromSocialValue(onlyFriendFromSocial_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOnlyFriendFromSocialValue(onlyFriendFromSocial_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(onlyFriendFromSocial_item)
      }
    
      @inline private[service] def readLeaderboardTypeValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardType = {
        xed.leaderboard.domain.thrift.TLeaderBoardType.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeLeaderboardTypeField(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(LeaderboardTypeFieldI32)
        writeLeaderboardTypeValue(leaderboardType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeLeaderboardTypeValue(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeI32(leaderboardType_item.value)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val myUsername: String,
        val from: Int,
        val to: Int,
        val onlyFriendFromSocial: Boolean,
        val leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product6[String, String, Int, Int, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        myUsername: String,
        from: Int,
        to: Int,
        onlyFriendFromSocial: Boolean,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ) = this(
        gameId,
        myUsername,
        from,
        to,
        onlyFriendFromSocial,
        leaderboardType,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = myUsername
      def _3 = from
      def _4 = to
      def _5 = onlyFriendFromSocial
      def _6 = leaderboardType
    
      def toTuple: _root_.scala.Tuple6[String, String, Int, Int, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]] = {
        (
          gameId,
          myUsername,
          from,
          to,
          onlyFriendFromSocial,
          leaderboardType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (myUsername ne null) writeMyUsernameField(myUsername, _oprot)
        writeFromField(from, _oprot)
        writeToField(to, _oprot)
        writeOnlyFriendFromSocialField(onlyFriendFromSocial, _oprot)
        if (leaderboardType.isDefined) writeLeaderboardTypeField(leaderboardType.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        myUsername: String = this.myUsername,
        from: Int = this.from,
        to: Int = this.to,
        onlyFriendFromSocial: Boolean = this.onlyFriendFromSocial,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = this.leaderboardType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          myUsername,
          from,
          to,
          onlyFriendFromSocial,
          leaderboardType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 6
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.myUsername
        case 2 => this.from
        case 3 => this.to
        case 4 => this.onlyFriendFromSocial
        case 5 => this.leaderboardType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TLeaderBoard
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeLeaderBoard_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoard]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TLeaderBoard.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoard = {
        xed.leaderboard.domain.thrift.TLeaderBoard.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TLeaderBoard, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TLeaderBoard, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TLeaderBoard] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TLeaderBoard]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TLeaderBoard] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TLeaderBoard]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TLeaderBoard]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getChallengeLeaderBoard"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getChallengeLeaderBoard$args = GetChallengeLeaderBoard.Args
  type getChallengeLeaderBoard$args = GetChallengeLeaderBoard.Args

  val getChallengeLeaderBoard$result = GetChallengeLeaderBoard.Result
  type getChallengeLeaderBoard$result = GetChallengeLeaderBoard.Result

  object GetChallengeUserRank extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserRank_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val OnlyFriendFromSocialField = new TField("onlyFriendFromSocial", TType.BOOL, 3)
      val OnlyFriendFromSocialFieldManifest = implicitly[Manifest[Boolean]]
      val LeaderboardTypeField = new TField("leaderboardType", TType.ENUM, 4)
      val LeaderboardTypeFieldI32 = new TField("leaderboardType", TType.I32, 4)
      val LeaderboardTypeFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardType]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          OnlyFriendFromSocialField,
          false,
          true,
          OnlyFriendFromSocialFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          LeaderboardTypeField,
          true,
          false,
          LeaderboardTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf ++= validateField(item.onlyFriendFromSocial)
        buf ++= validateField(item.leaderboardType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          username =
            {
              val field = original.username
              field
            },
          onlyFriendFromSocial =
            {
              val field = original.onlyFriendFromSocial
              field
            },
          leaderboardType =
            {
              val field = original.leaderboardType
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var username: String = null
        var _got_username = false
        var onlyFriendFromSocial: Boolean = false
        var _got_onlyFriendFromSocial = false
        var leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.BOOL =>
                    onlyFriendFromSocial = readOnlyFriendFromSocialValue(_iprot)
                    _got_onlyFriendFromSocial = true
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'onlyFriendFromSocial' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    leaderboardType = _root_.scala.Some(readLeaderboardTypeValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'leaderboardType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_onlyFriendFromSocial) throw new TProtocolException("Required field 'onlyFriendFromSocial' was not found in serialized data for struct Args")
        new Args(
          gameId,
          username,
          onlyFriendFromSocial,
          leaderboardType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        username: String,
        onlyFriendFromSocial: Boolean,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ): Args =
        new Args(
          gameId,
          username,
          onlyFriendFromSocial,
          leaderboardType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[String, String, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readOnlyFriendFromSocialValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeOnlyFriendFromSocialField(onlyFriendFromSocial_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OnlyFriendFromSocialField)
        writeOnlyFriendFromSocialValue(onlyFriendFromSocial_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOnlyFriendFromSocialValue(onlyFriendFromSocial_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(onlyFriendFromSocial_item)
      }
    
      @inline private[service] def readLeaderboardTypeValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardType = {
        xed.leaderboard.domain.thrift.TLeaderBoardType.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeLeaderboardTypeField(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(LeaderboardTypeFieldI32)
        writeLeaderboardTypeValue(leaderboardType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeLeaderboardTypeValue(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeI32(leaderboardType_item.value)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val username: String,
        val onlyFriendFromSocial: Boolean,
        val leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[String, String, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        username: String,
        onlyFriendFromSocial: Boolean,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ) = this(
        gameId,
        username,
        onlyFriendFromSocial,
        leaderboardType,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = username
      def _3 = onlyFriendFromSocial
      def _4 = leaderboardType
    
      def toTuple: _root_.scala.Tuple4[String, String, Boolean, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]] = {
        (
          gameId,
          username,
          onlyFriendFromSocial,
          leaderboardType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        writeOnlyFriendFromSocialField(onlyFriendFromSocial, _oprot)
        if (leaderboardType.isDefined) writeLeaderboardTypeField(leaderboardType.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        username: String = this.username,
        onlyFriendFromSocial: Boolean = this.onlyFriendFromSocial,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = this.leaderboardType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          username,
          onlyFriendFromSocial,
          leaderboardType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.username
        case 2 => this.onlyFriendFromSocial
        case 3 => this.leaderboardType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TLeaderBoardItemResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserRank_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TLeaderBoardItemResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardItemResp = {
        xed.leaderboard.domain.thrift.TLeaderBoardItemResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TLeaderBoardItemResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TLeaderBoardItemResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getChallengeUserRank"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getChallengeUserRank$args = GetChallengeUserRank.Args
  type getChallengeUserRank$args = GetChallengeUserRank.Args

  val getChallengeUserRank$result = GetChallengeUserRank.Result
  type getChallengeUserRank$result = GetChallengeUserRank.Result

  object SetChallengeUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPoint_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PointInfoField = new TField("pointInfo", TType.STRUCT, 3)
      val PointInfoFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PointInfoField,
          false,
          true,
          PointInfoFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.pointInfo == null) throw new TProtocolException("Required field pointInfo cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        if (item.pointInfo == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(2))
        buf ++= validateField(item.pointInfo)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          username =
            {
              val field = original.username
              field
            },
          pointInfo =
            {
              val field = original.pointInfo
              xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var username: String = null
        var _got_username = false
        var pointInfo: xed.leaderboard.domain.thrift.TPointInfo = null
        var _got_pointInfo = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pointInfo = readPointInfoValue(_iprot)
                    _got_pointInfo = true
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pointInfo' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_pointInfo) throw new TProtocolException("Required field 'pointInfo' was not found in serialized data for struct Args")
        new Args(
          gameId,
          username,
          pointInfo,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ): Args =
        new Args(
          gameId,
          username,
          pointInfo
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, String, xed.leaderboard.domain.thrift.TPointInfo]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPointInfoValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TPointInfo = {
        xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
      }
    
      @inline private def writePointInfoField(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PointInfoField)
        writePointInfoValue(pointInfo_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePointInfoValue(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        pointInfo_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val username: String,
        val pointInfo: xed.leaderboard.domain.thrift.TPointInfo,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, String, xed.leaderboard.domain.thrift.TPointInfo]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ) = this(
        gameId,
        username,
        pointInfo,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = username
      def _3 = pointInfo
    
      def toTuple: _root_.scala.Tuple3[String, String, xed.leaderboard.domain.thrift.TPointInfo] = {
        (
          gameId,
          username,
          pointInfo
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (pointInfo ne null) writePointInfoField(pointInfo, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        username: String = this.username,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo = this.pointInfo,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          username,
          pointInfo,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.username
        case 2 => this.pointInfo
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPoint_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setChallengeUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setChallengeUserPoint$args = SetChallengeUserPoint.Args
  type setChallengeUserPoint$args = SetChallengeUserPoint.Args

  val setChallengeUserPoint$result = SetChallengeUserPoint.Result
  type setChallengeUserPoint$result = SetChallengeUserPoint.Result

  object SetChallengeUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPoints_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UserPointsField = new TField("userPoints", TType.MAP, 2)
      val UserPointsFieldManifest = implicitly[Manifest[Map[String, xed.leaderboard.domain.thrift.TPointInfo]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UserPointsField,
          false,
          true,
          UserPointsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.userPoints == null) throw new TProtocolException("Required field userPoints cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.userPoints == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.userPoints)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          userPoints =
            {
              val field = original.userPoints
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
        var _got_userPoints = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.MAP =>
                    userPoints = readUserPointsValue(_iprot)
                    _got_userPoints = true
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'userPoints' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_userPoints) throw new TProtocolException("Required field 'userPoints' was not found in serialized data for struct Args")
        new Args(
          gameId,
          userPoints,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ): Args =
        new Args(
          gameId,
          userPoints
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUserPointsValue(_iprot: TProtocol): Map[String, xed.leaderboard.domain.thrift.TPointInfo] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, xed.leaderboard.domain.thrift.TPointInfo]
        } else {
          val _rv = new mutable$HashMap[String, xed.leaderboard.domain.thrift.TPointInfo]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeUserPointsField(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UserPointsField)
        writeUserPointsValue(userPoints_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUserPointsValue(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, userPoints_item.size))
        userPoints_item.foreach { case (userPoints_item_key, userPoints_item_value) =>
          _oprot.writeString(userPoints_item_key)
          userPoints_item_value.write(_oprot)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ) = this(
        gameId,
        userPoints,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = userPoints
    
      def toTuple: _root_.scala.Tuple2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]] = {
        (
          gameId,
          userPoints
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (userPoints ne null) writeUserPointsField(userPoints, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = this.userPoints,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          userPoints,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.userPoints
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPoints_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setChallengeUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setChallengeUserPoints$args = SetChallengeUserPoints.Args
  type setChallengeUserPoints$args = SetChallengeUserPoints.Args

  val setChallengeUserPoints$result = SetChallengeUserPoints.Result
  type setChallengeUserPoints$result = SetChallengeUserPoints.Result

  object SetChallengeUserPointIfHighest extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPointIfHighest_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PointInfoField = new TField("pointInfo", TType.STRUCT, 3)
      val PointInfoFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PointInfoField,
          false,
          true,
          PointInfoFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.pointInfo == null) throw new TProtocolException("Required field pointInfo cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        if (item.pointInfo == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(2))
        buf ++= validateField(item.pointInfo)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          username =
            {
              val field = original.username
              field
            },
          pointInfo =
            {
              val field = original.pointInfo
              xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var username: String = null
        var _got_username = false
        var pointInfo: xed.leaderboard.domain.thrift.TPointInfo = null
        var _got_pointInfo = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pointInfo = readPointInfoValue(_iprot)
                    _got_pointInfo = true
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pointInfo' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_pointInfo) throw new TProtocolException("Required field 'pointInfo' was not found in serialized data for struct Args")
        new Args(
          gameId,
          username,
          pointInfo,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ): Args =
        new Args(
          gameId,
          username,
          pointInfo
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, String, xed.leaderboard.domain.thrift.TPointInfo]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPointInfoValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TPointInfo = {
        xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
      }
    
      @inline private def writePointInfoField(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PointInfoField)
        writePointInfoValue(pointInfo_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePointInfoValue(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        pointInfo_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val username: String,
        val pointInfo: xed.leaderboard.domain.thrift.TPointInfo,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, String, xed.leaderboard.domain.thrift.TPointInfo]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ) = this(
        gameId,
        username,
        pointInfo,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = username
      def _3 = pointInfo
    
      def toTuple: _root_.scala.Tuple3[String, String, xed.leaderboard.domain.thrift.TPointInfo] = {
        (
          gameId,
          username,
          pointInfo
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (pointInfo ne null) writePointInfoField(pointInfo, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        username: String = this.username,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo = this.pointInfo,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          username,
          pointInfo,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.username
        case 2 => this.pointInfo
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPointIfHighest_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setChallengeUserPointIfHighest"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setChallengeUserPointIfHighest$args = SetChallengeUserPointIfHighest.Args
  type setChallengeUserPointIfHighest$args = SetChallengeUserPointIfHighest.Args

  val setChallengeUserPointIfHighest$result = SetChallengeUserPointIfHighest.Result
  type setChallengeUserPointIfHighest$result = SetChallengeUserPointIfHighest.Result

  object SetChallengeUserPointsIfHighest extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPointsIfHighest_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UserPointsField = new TField("userPoints", TType.MAP, 2)
      val UserPointsFieldManifest = implicitly[Manifest[Map[String, xed.leaderboard.domain.thrift.TPointInfo]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UserPointsField,
          false,
          true,
          UserPointsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.userPoints == null) throw new TProtocolException("Required field userPoints cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.userPoints == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.userPoints)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          userPoints =
            {
              val field = original.userPoints
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
        var _got_userPoints = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.MAP =>
                    userPoints = readUserPointsValue(_iprot)
                    _got_userPoints = true
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'userPoints' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_userPoints) throw new TProtocolException("Required field 'userPoints' was not found in serialized data for struct Args")
        new Args(
          gameId,
          userPoints,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ): Args =
        new Args(
          gameId,
          userPoints
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUserPointsValue(_iprot: TProtocol): Map[String, xed.leaderboard.domain.thrift.TPointInfo] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, xed.leaderboard.domain.thrift.TPointInfo]
        } else {
          val _rv = new mutable$HashMap[String, xed.leaderboard.domain.thrift.TPointInfo]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeUserPointsField(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UserPointsField)
        writeUserPointsValue(userPoints_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUserPointsValue(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, userPoints_item.size))
        userPoints_item.foreach { case (userPoints_item_key, userPoints_item_value) =>
          _oprot.writeString(userPoints_item_key)
          userPoints_item_value.write(_oprot)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ) = this(
        gameId,
        userPoints,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = userPoints
    
      def toTuple: _root_.scala.Tuple2[String, Map[String, xed.leaderboard.domain.thrift.TPointInfo]] = {
        (
          gameId,
          userPoints
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (userPoints ne null) writeUserPointsField(userPoints, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = this.userPoints,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          userPoints,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.userPoints
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setChallengeUserPointsIfHighest_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setChallengeUserPointsIfHighest"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setChallengeUserPointsIfHighest$args = SetChallengeUserPointsIfHighest.Args
  type setChallengeUserPointsIfHighest$args = SetChallengeUserPointsIfHighest.Args

  val setChallengeUserPointsIfHighest$result = SetChallengeUserPointsIfHighest.Result
  type setChallengeUserPointsIfHighest$result = SetChallengeUserPointsIfHighest.Result

  object GetChallengeUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserPoint_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val LeaderboardTypeField = new TField("leaderboardType", TType.ENUM, 3)
      val LeaderboardTypeFieldI32 = new TField("leaderboardType", TType.I32, 3)
      val LeaderboardTypeFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardType]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          LeaderboardTypeField,
          true,
          false,
          LeaderboardTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf ++= validateField(item.leaderboardType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          username =
            {
              val field = original.username
              field
            },
          leaderboardType =
            {
              val field = original.leaderboardType
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var username: String = null
        var _got_username = false
        var leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    leaderboardType = _root_.scala.Some(readLeaderboardTypeValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'leaderboardType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          gameId,
          username,
          leaderboardType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        username: String,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ): Args =
        new Args(
          gameId,
          username,
          leaderboardType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, String, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readLeaderboardTypeValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardType = {
        xed.leaderboard.domain.thrift.TLeaderBoardType.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeLeaderboardTypeField(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(LeaderboardTypeFieldI32)
        writeLeaderboardTypeValue(leaderboardType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeLeaderboardTypeValue(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeI32(leaderboardType_item.value)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val username: String,
        val leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, String, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        username: String,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ) = this(
        gameId,
        username,
        leaderboardType,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = username
      def _3 = leaderboardType
    
      def toTuple: _root_.scala.Tuple3[String, String, Option[xed.leaderboard.domain.thrift.TLeaderBoardType]] = {
        (
          gameId,
          username,
          leaderboardType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (leaderboardType.isDefined) writeLeaderboardTypeField(leaderboardType.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        username: String = this.username,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = this.leaderboardType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          username,
          leaderboardType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.username
        case 2 => this.leaderboardType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TUserPointResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserPoint_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TUserPointResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TUserPointResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TUserPointResp = {
        xed.leaderboard.domain.thrift.TUserPointResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TUserPointResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TUserPointResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TUserPointResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TUserPointResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TUserPointResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TUserPointResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TUserPointResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getChallengeUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getChallengeUserPoint$args = GetChallengeUserPoint.Args
  type getChallengeUserPoint$args = GetChallengeUserPoint.Args

  val getChallengeUserPoint$result = GetChallengeUserPoint.Result
  type getChallengeUserPoint$result = GetChallengeUserPoint.Result

  object GetChallengeUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserPoints_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernamesField = new TField("usernames", TType.LIST, 2)
      val UsernamesFieldManifest = implicitly[Manifest[Seq[String]]]
      val LeaderboardTypeField = new TField("leaderboardType", TType.ENUM, 3)
      val LeaderboardTypeFieldI32 = new TField("leaderboardType", TType.I32, 3)
      val LeaderboardTypeFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardType]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernamesField,
          false,
          true,
          UsernamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          LeaderboardTypeField,
          true,
          false,
          LeaderboardTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.usernames == null) throw new TProtocolException("Required field usernames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.usernames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.usernames)
        buf ++= validateField(item.leaderboardType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          usernames =
            {
              val field = original.usernames
              field.map { field =>
                field
              }
            },
          leaderboardType =
            {
              val field = original.leaderboardType
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var usernames: Seq[String] = Seq[String]()
        var _got_usernames = false
        var leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    usernames = readUsernamesValue(_iprot)
                    _got_usernames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'usernames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    leaderboardType = _root_.scala.Some(readLeaderboardTypeValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'leaderboardType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_usernames) throw new TProtocolException("Required field 'usernames' was not found in serialized data for struct Args")
        new Args(
          gameId,
          usernames,
          leaderboardType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        usernames: Seq[String] = Seq[String](),
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ): Args =
        new Args(
          gameId,
          usernames,
          leaderboardType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, Seq[String], Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeUsernamesField(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernamesField)
        writeUsernamesValue(usernames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernamesValue(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, usernames_item.size))
        usernames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = usernames_item.size
            while (_i < _size) {
              val usernames_item_element = usernames_item(_i)
              _oprot.writeString(usernames_item_element)
              _i += 1
            }
          case _ =>
            usernames_item.foreach { usernames_item_element =>
              _oprot.writeString(usernames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[service] def readLeaderboardTypeValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardType = {
        xed.leaderboard.domain.thrift.TLeaderBoardType.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeLeaderboardTypeField(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(LeaderboardTypeFieldI32)
        writeLeaderboardTypeValue(leaderboardType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeLeaderboardTypeValue(leaderboardType_item: xed.leaderboard.domain.thrift.TLeaderBoardType, _oprot: TProtocol): Unit = {
        _oprot.writeI32(leaderboardType_item.value)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val usernames: Seq[String],
        val leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, Seq[String], Option[xed.leaderboard.domain.thrift.TLeaderBoardType]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        usernames: Seq[String] = Seq[String](),
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = _root_.scala.None
      ) = this(
        gameId,
        usernames,
        leaderboardType,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = usernames
      def _3 = leaderboardType
    
      def toTuple: _root_.scala.Tuple3[String, Seq[String], Option[xed.leaderboard.domain.thrift.TLeaderBoardType]] = {
        (
          gameId,
          usernames,
          leaderboardType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (usernames ne null) writeUsernamesField(usernames, _oprot)
        if (leaderboardType.isDefined) writeLeaderboardTypeField(leaderboardType.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        usernames: Seq[String] = this.usernames,
        leaderboardType: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = this.leaderboardType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          usernames,
          leaderboardType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.usernames
        case 2 => this.leaderboardType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TMultiGetUserPointResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getChallengeUserPoints_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TMultiGetUserPointResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TMultiGetUserPointResp = {
        xed.leaderboard.domain.thrift.TMultiGetUserPointResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TMultiGetUserPointResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TMultiGetUserPointResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getChallengeUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getChallengeUserPoints$args = GetChallengeUserPoints.Args
  type getChallengeUserPoints$args = GetChallengeUserPoints.Args

  val getChallengeUserPoints$result = GetChallengeUserPoints.Result
  type getChallengeUserPoints$result = GetChallengeUserPoints.Result

  object DelChallengeUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delChallengeUserPoints_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernamesField = new TField("usernames", TType.LIST, 2)
      val UsernamesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernamesField,
          false,
          true,
          UsernamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.usernames == null) throw new TProtocolException("Required field usernames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.usernames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.usernames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          usernames =
            {
              val field = original.usernames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var usernames: Seq[String] = Seq[String]()
        var _got_usernames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    usernames = readUsernamesValue(_iprot)
                    _got_usernames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'usernames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_usernames) throw new TProtocolException("Required field 'usernames' was not found in serialized data for struct Args")
        new Args(
          gameId,
          usernames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        usernames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          gameId,
          usernames
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeUsernamesField(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernamesField)
        writeUsernamesValue(usernames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernamesValue(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, usernames_item.size))
        usernames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = usernames_item.size
            while (_i < _size) {
              val usernames_item_element = usernames_item(_i)
              _oprot.writeString(usernames_item_element)
              _i += 1
            }
          case _ =>
            usernames_item.foreach { usernames_item_element =>
              _oprot.writeString(usernames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val usernames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        usernames: Seq[String] = Seq[String]()
      ) = this(
        gameId,
        usernames,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = usernames
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          gameId,
          usernames
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (usernames ne null) writeUsernamesField(usernames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        usernames: Seq[String] = this.usernames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          usernames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.usernames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delChallengeUserPoints_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "delChallengeUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val delChallengeUserPoints$args = DelChallengeUserPoints.Args
  type delChallengeUserPoints$args = DelChallengeUserPoints.Args

  val delChallengeUserPoints$result = DelChallengeUserPoints.Result
  type delChallengeUserPoints$result = DelChallengeUserPoints.Result

  object DelChallengeUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delChallengeUserPoint_args")
      val GameIdField = new TField("gameId", TType.STRING, 1)
      val GameIdFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GameIdField,
          false,
          true,
          GameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.gameId == null) throw new TProtocolException("Required field gameId cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.gameId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.gameId)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gameId =
            {
              val field = original.gameId
              field
            },
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gameId: String = null
        var _got_gameId = false
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    gameId = readGameIdValue(_iprot)
                    _got_gameId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'gameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_gameId) throw new TProtocolException("Required field 'gameId' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          gameId,
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gameId: String,
        username: String
      ): Args =
        new Args(
          gameId,
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readGameIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeGameIdField(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GameIdField)
        writeGameIdValue(gameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGameIdValue(gameId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(gameId_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val gameId: String,
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        gameId: String,
        username: String
      ) = this(
        gameId,
        username,
        Map.empty
      )
    
      def _1 = gameId
      def _2 = username
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          gameId,
          username
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gameId ne null) writeGameIdField(gameId, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gameId: String = this.gameId,
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gameId,
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gameId
        case 1 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delChallengeUserPoint_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "delChallengeUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val delChallengeUserPoint$args = DelChallengeUserPoint.Args
  type delChallengeUserPoint$args = DelChallengeUserPoint.Args

  val delChallengeUserPoint$result = DelChallengeUserPoint.Result
  type delChallengeUserPoint$result = DelChallengeUserPoint.Result

  object GetSocialLeaderBoard extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialLeaderBoard_args")
      val OwnerField = new TField("owner", TType.STRING, 1)
      val OwnerFieldManifest = implicitly[Manifest[String]]
      val FromField = new TField("from", TType.I32, 2)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val ToField = new TField("to", TType.I32, 3)
      val ToFieldManifest = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OwnerField,
          false,
          true,
          OwnerFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ToField,
          false,
          true,
          ToFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.owner == null) throw new TProtocolException("Required field owner cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.owner == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.owner)
        buf ++= validateField(item.from)
        buf ++= validateField(item.to)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          owner =
            {
              val field = original.owner
              field
            },
          from =
            {
              val field = original.from
              field
            },
          to =
            {
              val field = original.to
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var owner: String = null
        var _got_owner = false
        var from: Int = 0
        var _got_from = false
        var to: Int = 0
        var _got_to = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    owner = readOwnerValue(_iprot)
                    _got_owner = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'owner' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    to = readToValue(_iprot)
                    _got_to = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'to' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_owner) throw new TProtocolException("Required field 'owner' was not found in serialized data for struct Args")
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_to) throw new TProtocolException("Required field 'to' was not found in serialized data for struct Args")
        new Args(
          owner,
          from,
          to,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        owner: String,
        from: Int,
        to: Int
      ): Args =
        new Args(
          owner,
          from,
          to
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOwnerValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOwnerField(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OwnerField)
        writeOwnerValue(owner_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOwnerValue(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(owner_item)
      }
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readToValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeToField(to_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ToField)
        writeToValue(to_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeToValue(to_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(to_item)
      }
    
    
    }
    
    class Args(
        val owner: String,
        val from: Int,
        val to: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        owner: String,
        from: Int,
        to: Int
      ) = this(
        owner,
        from,
        to,
        Map.empty
      )
    
      def _1 = owner
      def _2 = from
      def _3 = to
    
      def toTuple: _root_.scala.Tuple3[String, Int, Int] = {
        (
          owner,
          from,
          to
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (owner ne null) writeOwnerField(owner, _oprot)
        writeFromField(from, _oprot)
        writeToField(to, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        owner: String = this.owner,
        from: Int = this.from,
        to: Int = this.to,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          owner,
          from,
          to,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.owner
        case 1 => this.from
        case 2 => this.to
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TLeaderBoard
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialLeaderBoard_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoard]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TLeaderBoard.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoard = {
        xed.leaderboard.domain.thrift.TLeaderBoard.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TLeaderBoard, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TLeaderBoard, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TLeaderBoard] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TLeaderBoard]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TLeaderBoard] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoard] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TLeaderBoard]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TLeaderBoard]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getSocialLeaderBoard"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getSocialLeaderBoard$args = GetSocialLeaderBoard.Args
  type getSocialLeaderBoard$args = GetSocialLeaderBoard.Args

  val getSocialLeaderBoard$result = GetSocialLeaderBoard.Result
  type getSocialLeaderBoard$result = GetSocialLeaderBoard.Result

  object GetSocialUserRank extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserRank_args")
      val OwnerField = new TField("owner", TType.STRING, 1)
      val OwnerFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OwnerField,
          false,
          true,
          OwnerFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.owner == null) throw new TProtocolException("Required field owner cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.owner == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.owner)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          owner =
            {
              val field = original.owner
              field
            },
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var owner: String = null
        var _got_owner = false
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    owner = readOwnerValue(_iprot)
                    _got_owner = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'owner' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_owner) throw new TProtocolException("Required field 'owner' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          owner,
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        owner: String,
        username: String
      ): Args =
        new Args(
          owner,
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOwnerValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOwnerField(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OwnerField)
        writeOwnerValue(owner_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOwnerValue(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(owner_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val owner: String,
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        owner: String,
        username: String
      ) = this(
        owner,
        username,
        Map.empty
      )
    
      def _1 = owner
      def _2 = username
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          owner,
          username
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (owner ne null) writeOwnerField(owner, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        owner: String = this.owner,
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          owner,
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.owner
        case 1 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TLeaderBoardItemResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserRank_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TLeaderBoardItemResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TLeaderBoardItemResp = {
        xed.leaderboard.domain.thrift.TLeaderBoardItemResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TLeaderBoardItemResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TLeaderBoardItemResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getSocialUserRank"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getSocialUserRank$args = GetSocialUserRank.Args
  type getSocialUserRank$args = GetSocialUserRank.Args

  val getSocialUserRank$result = GetSocialUserRank.Result
  type getSocialUserRank$result = GetSocialUserRank.Result

  object SetSocialFriendList extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialFriendList_args")
      val OwnerField = new TField("owner", TType.STRING, 1)
      val OwnerFieldManifest = implicitly[Manifest[String]]
      val FriendUserNamesField = new TField("friendUserNames", TType.LIST, 2)
      val FriendUserNamesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OwnerField,
          false,
          true,
          OwnerFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FriendUserNamesField,
          false,
          true,
          FriendUserNamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.owner == null) throw new TProtocolException("Required field owner cannot be null")
        if (_item.friendUserNames == null) throw new TProtocolException("Required field friendUserNames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.owner == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.owner)
        if (item.friendUserNames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.friendUserNames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          owner =
            {
              val field = original.owner
              field
            },
          friendUserNames =
            {
              val field = original.friendUserNames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var owner: String = null
        var _got_owner = false
        var friendUserNames: Seq[String] = Seq[String]()
        var _got_friendUserNames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    owner = readOwnerValue(_iprot)
                    _got_owner = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'owner' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    friendUserNames = readFriendUserNamesValue(_iprot)
                    _got_friendUserNames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'friendUserNames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_owner) throw new TProtocolException("Required field 'owner' was not found in serialized data for struct Args")
        if (!_got_friendUserNames) throw new TProtocolException("Required field 'friendUserNames' was not found in serialized data for struct Args")
        new Args(
          owner,
          friendUserNames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        owner: String,
        friendUserNames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          owner,
          friendUserNames
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOwnerValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOwnerField(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OwnerField)
        writeOwnerValue(owner_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOwnerValue(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(owner_item)
      }
    
      @inline private[service] def readFriendUserNamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeFriendUserNamesField(friendUserNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FriendUserNamesField)
        writeFriendUserNamesValue(friendUserNames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFriendUserNamesValue(friendUserNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, friendUserNames_item.size))
        friendUserNames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = friendUserNames_item.size
            while (_i < _size) {
              val friendUserNames_item_element = friendUserNames_item(_i)
              _oprot.writeString(friendUserNames_item_element)
              _i += 1
            }
          case _ =>
            friendUserNames_item.foreach { friendUserNames_item_element =>
              _oprot.writeString(friendUserNames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val owner: String,
        val friendUserNames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        owner: String,
        friendUserNames: Seq[String] = Seq[String]()
      ) = this(
        owner,
        friendUserNames,
        Map.empty
      )
    
      def _1 = owner
      def _2 = friendUserNames
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          owner,
          friendUserNames
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (owner ne null) writeOwnerField(owner, _oprot)
        if (friendUserNames ne null) writeFriendUserNamesField(friendUserNames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        owner: String = this.owner,
        friendUserNames: Seq[String] = this.friendUserNames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          owner,
          friendUserNames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.owner
        case 1 => this.friendUserNames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialFriendList_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setSocialFriendList"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setSocialFriendList$args = SetSocialFriendList.Args
  type setSocialFriendList$args = SetSocialFriendList.Args

  val setSocialFriendList$result = SetSocialFriendList.Result
  type setSocialFriendList$result = SetSocialFriendList.Result

  object AddSocialFriend extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("addSocialFriend_args")
      val OwnerField = new TField("owner", TType.STRING, 1)
      val OwnerFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OwnerField,
          false,
          true,
          OwnerFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.owner == null) throw new TProtocolException("Required field owner cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.owner == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.owner)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          owner =
            {
              val field = original.owner
              field
            },
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var owner: String = null
        var _got_owner = false
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    owner = readOwnerValue(_iprot)
                    _got_owner = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'owner' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_owner) throw new TProtocolException("Required field 'owner' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          owner,
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        owner: String,
        username: String
      ): Args =
        new Args(
          owner,
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOwnerValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOwnerField(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OwnerField)
        writeOwnerValue(owner_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOwnerValue(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(owner_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val owner: String,
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        owner: String,
        username: String
      ) = this(
        owner,
        username,
        Map.empty
      )
    
      def _1 = owner
      def _2 = username
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          owner,
          username
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (owner ne null) writeOwnerField(owner, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        owner: String = this.owner,
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          owner,
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.owner
        case 1 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("addSocialFriend_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "addSocialFriend"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val addSocialFriend$args = AddSocialFriend.Args
  type addSocialFriend$args = AddSocialFriend.Args

  val addSocialFriend$result = AddSocialFriend.Result
  type addSocialFriend$result = AddSocialFriend.Result

  object RemoveSocialFriend extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("removeSocialFriend_args")
      val OwnerField = new TField("owner", TType.STRING, 1)
      val OwnerFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OwnerField,
          false,
          true,
          OwnerFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.owner == null) throw new TProtocolException("Required field owner cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.owner == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.owner)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          owner =
            {
              val field = original.owner
              field
            },
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var owner: String = null
        var _got_owner = false
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    owner = readOwnerValue(_iprot)
                    _got_owner = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'owner' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_owner) throw new TProtocolException("Required field 'owner' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          owner,
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        owner: String,
        username: String
      ): Args =
        new Args(
          owner,
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOwnerValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOwnerField(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OwnerField)
        writeOwnerValue(owner_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOwnerValue(owner_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(owner_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val owner: String,
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        owner: String,
        username: String
      ) = this(
        owner,
        username,
        Map.empty
      )
    
      def _1 = owner
      def _2 = username
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          owner,
          username
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (owner ne null) writeOwnerField(owner, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        owner: String = this.owner,
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          owner,
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.owner
        case 1 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("removeSocialFriend_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "removeSocialFriend"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val removeSocialFriend$args = RemoveSocialFriend.Args
  type removeSocialFriend$args = RemoveSocialFriend.Args

  val removeSocialFriend$result = RemoveSocialFriend.Result
  type removeSocialFriend$result = RemoveSocialFriend.Result

  object SetSocialUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialUserPoint_args")
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PointInfoField = new TField("pointInfo", TType.STRUCT, 3)
      val PointInfoFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PointInfoField,
          false,
          true,
          PointInfoFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.pointInfo == null) throw new TProtocolException("Required field pointInfo cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.pointInfo == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.pointInfo)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          pointInfo =
            {
              val field = original.pointInfo
              xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var pointInfo: xed.leaderboard.domain.thrift.TPointInfo = null
        var _got_pointInfo = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pointInfo = readPointInfoValue(_iprot)
                    _got_pointInfo = true
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pointInfo' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_pointInfo) throw new TProtocolException("Required field 'pointInfo' was not found in serialized data for struct Args")
        new Args(
          username,
          pointInfo,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ): Args =
        new Args(
          username,
          pointInfo
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, xed.leaderboard.domain.thrift.TPointInfo]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPointInfoValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TPointInfo = {
        xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
      }
    
      @inline private def writePointInfoField(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PointInfoField)
        writePointInfoValue(pointInfo_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePointInfoValue(pointInfo_item: xed.leaderboard.domain.thrift.TPointInfo, _oprot: TProtocol): Unit = {
        pointInfo_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val username: String,
        val pointInfo: xed.leaderboard.domain.thrift.TPointInfo,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, xed.leaderboard.domain.thrift.TPointInfo]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo
      ) = this(
        username,
        pointInfo,
        Map.empty
      )
    
      def _1 = username
      def _2 = pointInfo
    
      def toTuple: _root_.scala.Tuple2[String, xed.leaderboard.domain.thrift.TPointInfo] = {
        (
          username,
          pointInfo
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (pointInfo ne null) writePointInfoField(pointInfo, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        pointInfo: xed.leaderboard.domain.thrift.TPointInfo = this.pointInfo,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          pointInfo,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.pointInfo
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialUserPoint_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setSocialUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setSocialUserPoint$args = SetSocialUserPoint.Args
  type setSocialUserPoint$args = SetSocialUserPoint.Args

  val setSocialUserPoint$result = SetSocialUserPoint.Result
  type setSocialUserPoint$result = SetSocialUserPoint.Result

  object SetSocialUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialUserPoints_args")
      val UserPointsField = new TField("userPoints", TType.MAP, 1)
      val UserPointsFieldManifest = implicitly[Manifest[Map[String, xed.leaderboard.domain.thrift.TPointInfo]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UserPointsField,
          false,
          true,
          UserPointsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[xed.leaderboard.domain.thrift.TPointInfo]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.userPoints == null) throw new TProtocolException("Required field userPoints cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.userPoints == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.userPoints)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          userPoints =
            {
              val field = original.userPoints
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  xed.leaderboard.domain.thrift.TPointInfo.withoutPassthroughFields(field)
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
        var _got_userPoints = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.MAP =>
                    userPoints = readUserPointsValue(_iprot)
                    _got_userPoints = true
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'userPoints' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_userPoints) throw new TProtocolException("Required field 'userPoints' was not found in serialized data for struct Args")
        new Args(
          userPoints,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ): Args =
        new Args(
          userPoints
        )
    
      def unapply(_item: Args): _root_.scala.Option[Map[String, xed.leaderboard.domain.thrift.TPointInfo]] = _root_.scala.Some(_item.userPoints)
    
    
      @inline private[service] def readUserPointsValue(_iprot: TProtocol): Map[String, xed.leaderboard.domain.thrift.TPointInfo] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, xed.leaderboard.domain.thrift.TPointInfo]
        } else {
          val _rv = new mutable$HashMap[String, xed.leaderboard.domain.thrift.TPointInfo]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              xed.leaderboard.domain.thrift.TPointInfo.decode(_iprot)
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeUserPointsField(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UserPointsField)
        writeUserPointsValue(userPoints_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUserPointsValue(userPoints_item: Map[String, xed.leaderboard.domain.thrift.TPointInfo], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, userPoints_item.size))
        userPoints_item.foreach { case (userPoints_item_key, userPoints_item_value) =>
          _oprot.writeString(userPoints_item_key)
          userPoints_item_value.write(_oprot)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Map[String, xed.leaderboard.domain.thrift.TPointInfo]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()
      ) = this(
        userPoints,
        Map.empty
      )
    
      def _1 = userPoints
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (userPoints ne null) writeUserPointsField(userPoints, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = this.userPoints,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          userPoints,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.userPoints
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setSocialUserPoints_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setSocialUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setSocialUserPoints$args = SetSocialUserPoints.Args
  type setSocialUserPoints$args = SetSocialUserPoints.Args

  val setSocialUserPoints$result = SetSocialUserPoints.Result
  type setSocialUserPoints$result = SetSocialUserPoints.Result

  object GetSocialUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserPoint_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TUserPointResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserPoint_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TUserPointResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TUserPointResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TUserPointResp = {
        xed.leaderboard.domain.thrift.TUserPointResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TUserPointResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TUserPointResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TUserPointResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TUserPointResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TUserPointResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TUserPointResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TUserPointResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TUserPointResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getSocialUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getSocialUserPoint$args = GetSocialUserPoint.Args
  type getSocialUserPoint$args = GetSocialUserPoint.Args

  val getSocialUserPoint$result = GetSocialUserPoint.Result
  type getSocialUserPoint$result = GetSocialUserPoint.Result

  object GetSocialUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserPoints_args")
      val UsernamesField = new TField("usernames", TType.LIST, 1)
      val UsernamesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernamesField,
          false,
          true,
          UsernamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.usernames == null) throw new TProtocolException("Required field usernames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.usernames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.usernames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          usernames =
            {
              val field = original.usernames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var usernames: Seq[String] = Seq[String]()
        var _got_usernames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    usernames = readUsernamesValue(_iprot)
                    _got_usernames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'usernames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_usernames) throw new TProtocolException("Required field 'usernames' was not found in serialized data for struct Args")
        new Args(
          usernames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        usernames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          usernames
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[String]] = _root_.scala.Some(_item.usernames)
    
    
      @inline private[service] def readUsernamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeUsernamesField(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernamesField)
        writeUsernamesValue(usernames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernamesValue(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, usernames_item.size))
        usernames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = usernames_item.size
            while (_i < _size) {
              val usernames_item_element = usernames_item(_i)
              _oprot.writeString(usernames_item_element)
              _i += 1
            }
          case _ =>
            usernames_item.foreach { usernames_item_element =>
              _oprot.writeString(usernames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val usernames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        usernames: Seq[String] = Seq[String]()
      ) = this(
        usernames,
        Map.empty
      )
    
      def _1 = usernames
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (usernames ne null) writeUsernamesField(usernames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        usernames: Seq[String] = this.usernames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          usernames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.usernames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.leaderboard.domain.thrift.TMultiGetUserPointResp
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getSocialUserPoints_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.leaderboard.domain.thrift.TMultiGetUserPointResp.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TMultiGetUserPointResp = {
        xed.leaderboard.domain.thrift.TMultiGetUserPointResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.leaderboard.domain.thrift.TMultiGetUserPointResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.leaderboard.domain.thrift.TMultiGetUserPointResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] with ThriftStruct
      with _root_.scala.Product1[Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getSocialUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getSocialUserPoints$args = GetSocialUserPoints.Args
  type getSocialUserPoints$args = GetSocialUserPoints.Args

  val getSocialUserPoints$result = GetSocialUserPoints.Result
  type getSocialUserPoints$result = GetSocialUserPoints.Result

  object DelSocialUserPoint extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delSocialUserPoint_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delSocialUserPoint_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "delSocialUserPoint"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val delSocialUserPoint$args = DelSocialUserPoint.Args
  type delSocialUserPoint$args = DelSocialUserPoint.Args

  val delSocialUserPoint$result = DelSocialUserPoint.Result
  type delSocialUserPoint$result = DelSocialUserPoint.Result

  object DelSocialUserPoints extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delSocialUserPoints_args")
      val UsernamesField = new TField("usernames", TType.LIST, 1)
      val UsernamesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernamesField,
          false,
          true,
          UsernamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.usernames == null) throw new TProtocolException("Required field usernames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.usernames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.usernames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          usernames =
            {
              val field = original.usernames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var usernames: Seq[String] = Seq[String]()
        var _got_usernames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    usernames = readUsernamesValue(_iprot)
                    _got_usernames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'usernames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_usernames) throw new TProtocolException("Required field 'usernames' was not found in serialized data for struct Args")
        new Args(
          usernames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        usernames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          usernames
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[String]] = _root_.scala.Some(_item.usernames)
    
    
      @inline private[service] def readUsernamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeUsernamesField(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernamesField)
        writeUsernamesValue(usernames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernamesValue(usernames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, usernames_item.size))
        usernames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = usernames_item.size
            while (_i < _size) {
              val usernames_item_element = usernames_item(_i)
              _oprot.writeString(usernames_item_element)
              _i += 1
            }
          case _ =>
            usernames_item.foreach { usernames_item_element =>
              _oprot.writeString(usernames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val usernames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        usernames: Seq[String] = Seq[String]()
      ) = this(
        usernames,
        Map.empty
      )
    
      def _1 = usernames
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (usernames ne null) writeUsernamesField(usernames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        usernames: Seq[String] = this.usernames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          usernames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.usernames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("delSocialUserPoints_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "delSocialUserPoints"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val delSocialUserPoints$args = DelSocialUserPoints.Args
  type delSocialUserPoints$args = DelSocialUserPoints.Args

  val delSocialUserPoints$result = DelSocialUserPoints.Result
  type delSocialUserPoints$result = DelSocialUserPoints.Result

  object SetUserProfile extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setUserProfile_args")
      val UserProfileField = new TField("userProfile", TType.STRUCT, 1)
      val UserProfileFieldManifest = implicitly[Manifest[xed.leaderboard.domain.thrift.TShortUserProfile]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UserProfileField,
          false,
          true,
          UserProfileFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.userProfile == null) throw new TProtocolException("Required field userProfile cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.userProfile == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.userProfile)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          userProfile =
            {
              val field = original.userProfile
              xed.leaderboard.domain.thrift.TShortUserProfile.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var userProfile: xed.leaderboard.domain.thrift.TShortUserProfile = null
        var _got_userProfile = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    userProfile = readUserProfileValue(_iprot)
                    _got_userProfile = true
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'userProfile' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_userProfile) throw new TProtocolException("Required field 'userProfile' was not found in serialized data for struct Args")
        new Args(
          userProfile,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        userProfile: xed.leaderboard.domain.thrift.TShortUserProfile
      ): Args =
        new Args(
          userProfile
        )
    
      def unapply(_item: Args): _root_.scala.Option[xed.leaderboard.domain.thrift.TShortUserProfile] = _root_.scala.Some(_item.userProfile)
    
    
      @inline private[service] def readUserProfileValue(_iprot: TProtocol): xed.leaderboard.domain.thrift.TShortUserProfile = {
        xed.leaderboard.domain.thrift.TShortUserProfile.decode(_iprot)
      }
    
      @inline private def writeUserProfileField(userProfile_item: xed.leaderboard.domain.thrift.TShortUserProfile, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UserProfileField)
        writeUserProfileValue(userProfile_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUserProfileValue(userProfile_item: xed.leaderboard.domain.thrift.TShortUserProfile, _oprot: TProtocol): Unit = {
        userProfile_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val userProfile: xed.leaderboard.domain.thrift.TShortUserProfile,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[xed.leaderboard.domain.thrift.TShortUserProfile]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        userProfile: xed.leaderboard.domain.thrift.TShortUserProfile
      ) = this(
        userProfile,
        Map.empty
      )
    
      def _1 = userProfile
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (userProfile ne null) writeUserProfileField(userProfile, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        userProfile: xed.leaderboard.domain.thrift.TShortUserProfile = this.userProfile,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          userProfile,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.userProfile
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setUserProfile_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setUserProfile"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setUserProfile$args = SetUserProfile.Args
  type setUserProfile$args = SetUserProfile.Args

  val setUserProfile$result = SetUserProfile.Result
  type setUserProfile$result = SetUserProfile.Result

  object SetUserProfiles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setUserProfiles_args")
      val UserProfilesField = new TField("userProfiles", TType.LIST, 1)
      val UserProfilesFieldManifest = implicitly[Manifest[Seq[xed.leaderboard.domain.thrift.TShortUserProfile]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UserProfilesField,
          false,
          true,
          UserProfilesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[xed.leaderboard.domain.thrift.TShortUserProfile]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.userProfiles == null) throw new TProtocolException("Required field userProfiles cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.userProfiles == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.userProfiles)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          userProfiles =
            {
              val field = original.userProfiles
              field.map { field =>
                xed.leaderboard.domain.thrift.TShortUserProfile.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()
        var _got_userProfiles = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    userProfiles = readUserProfilesValue(_iprot)
                    _got_userProfiles = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'userProfiles' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_userProfiles) throw new TProtocolException("Required field 'userProfiles' was not found in serialized data for struct Args")
        new Args(
          userProfiles,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()
      ): Args =
        new Args(
          userProfiles
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[xed.leaderboard.domain.thrift.TShortUserProfile]] = _root_.scala.Some(_item.userProfiles)
    
    
      @inline private[service] def readUserProfilesValue(_iprot: TProtocol): Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[xed.leaderboard.domain.thrift.TShortUserProfile](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              xed.leaderboard.domain.thrift.TShortUserProfile.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeUserProfilesField(userProfiles_item: Seq[xed.leaderboard.domain.thrift.TShortUserProfile], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UserProfilesField)
        writeUserProfilesValue(userProfiles_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUserProfilesValue(userProfiles_item: Seq[xed.leaderboard.domain.thrift.TShortUserProfile], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, userProfiles_item.size))
        userProfiles_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = userProfiles_item.size
            while (_i < _size) {
              val userProfiles_item_element = userProfiles_item(_i)
              userProfiles_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            userProfiles_item.foreach { userProfiles_item_element =>
              userProfiles_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[xed.leaderboard.domain.thrift.TShortUserProfile]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()
      ) = this(
        userProfiles,
        Map.empty
      )
    
      def _1 = userProfiles
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (userProfiles ne null) writeUserProfilesField(userProfiles, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = this.userProfiles,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          userProfiles,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.userProfiles
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("setUserProfiles_result")
      val SuccessField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Boolean]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product1[Option[Boolean]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "setUserProfiles"
    val serviceName: String = "TLeaderBoardMWService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setUserProfiles$args = SetUserProfiles.Args
  type setUserProfiles$args = SetUserProfiles.Args

  val setUserProfiles$result = SetUserProfiles.Result
  type setUserProfiles$result = SetUserProfiles.Result


  trait MethodPerEndpoint
    extends TLeaderBoardMWService[Future] {
    
    def ping(): Future[String]
    
    def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoard]
    
    def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
    
    def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TUserPointResp]
    
    def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
    
    def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def delChallengeUserPoint(gameId: String, username: String): Future[Boolean]
    
    def getSocialLeaderBoard(owner: String, from: Int, to: Int): Future[xed.leaderboard.domain.thrift.TLeaderBoard]
    
    def getSocialUserRank(owner: String, username: String): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
    
    def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def addSocialFriend(owner: String, username: String): Future[Boolean]
    
    def removeSocialFriend(owner: String, username: String): Future[Boolean]
    
    def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def getSocialUserPoint(username: String): Future[xed.leaderboard.domain.thrift.TUserPointResp]
    
    def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
    
    def delSocialUserPoint(username: String): Future[Boolean]
    
    def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): Future[Boolean]
    
    def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): Future[Boolean]
  }

  object MethodPerEndpoint {

    def apply(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint = {
      new MethodPerEndpointImpl(servicePerEndpoint) {}
    }

    /**
     * Use `MethodPerEndpoint.apply()` instead of this constructor.
     */
    class MethodPerEndpointImpl protected (servicePerEndpoint: ServicePerEndpoint)
      extends MethodPerEndpoint {
        def ping(): Future[String] =
          servicePerEndpoint.ping(self.Ping.Args())
        def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoard] =
          servicePerEndpoint.getChallengeLeaderBoard(self.GetChallengeLeaderBoard.Args(gameId, myUsername, from, to, onlyFriendFromSocial, leaderboardType))
        def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] =
          servicePerEndpoint.getChallengeUserRank(self.GetChallengeUserRank.Args(gameId, username, onlyFriendFromSocial, leaderboardType))
        def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
          servicePerEndpoint.setChallengeUserPoint(self.SetChallengeUserPoint.Args(gameId, username, pointInfo))
        def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
          servicePerEndpoint.setChallengeUserPoints(self.SetChallengeUserPoints.Args(gameId, userPoints))
        def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
          servicePerEndpoint.setChallengeUserPointIfHighest(self.SetChallengeUserPointIfHighest.Args(gameId, username, pointInfo))
        def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
          servicePerEndpoint.setChallengeUserPointsIfHighest(self.SetChallengeUserPointsIfHighest.Args(gameId, userPoints))
        def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TUserPointResp] =
          servicePerEndpoint.getChallengeUserPoint(self.GetChallengeUserPoint.Args(gameId, username, leaderboardType))
        def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] =
          servicePerEndpoint.getChallengeUserPoints(self.GetChallengeUserPoints.Args(gameId, usernames, leaderboardType))
        def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): Future[Boolean] =
          servicePerEndpoint.delChallengeUserPoints(self.DelChallengeUserPoints.Args(gameId, usernames))
        def delChallengeUserPoint(gameId: String, username: String): Future[Boolean] =
          servicePerEndpoint.delChallengeUserPoint(self.DelChallengeUserPoint.Args(gameId, username))
        def getSocialLeaderBoard(owner: String, from: Int, to: Int): Future[xed.leaderboard.domain.thrift.TLeaderBoard] =
          servicePerEndpoint.getSocialLeaderBoard(self.GetSocialLeaderBoard.Args(owner, from, to))
        def getSocialUserRank(owner: String, username: String): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] =
          servicePerEndpoint.getSocialUserRank(self.GetSocialUserRank.Args(owner, username))
        def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): Future[Boolean] =
          servicePerEndpoint.setSocialFriendList(self.SetSocialFriendList.Args(owner, friendUserNames))
        def addSocialFriend(owner: String, username: String): Future[Boolean] =
          servicePerEndpoint.addSocialFriend(self.AddSocialFriend.Args(owner, username))
        def removeSocialFriend(owner: String, username: String): Future[Boolean] =
          servicePerEndpoint.removeSocialFriend(self.RemoveSocialFriend.Args(owner, username))
        def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
          servicePerEndpoint.setSocialUserPoint(self.SetSocialUserPoint.Args(username, pointInfo))
        def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
          servicePerEndpoint.setSocialUserPoints(self.SetSocialUserPoints.Args(userPoints))
        def getSocialUserPoint(username: String): Future[xed.leaderboard.domain.thrift.TUserPointResp] =
          servicePerEndpoint.getSocialUserPoint(self.GetSocialUserPoint.Args(username))
        def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] =
          servicePerEndpoint.getSocialUserPoints(self.GetSocialUserPoints.Args(usernames))
        def delSocialUserPoint(username: String): Future[Boolean] =
          servicePerEndpoint.delSocialUserPoint(self.DelSocialUserPoint.Args(username))
        def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[Boolean] =
          servicePerEndpoint.delSocialUserPoints(self.DelSocialUserPoints.Args(usernames))
        def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): Future[Boolean] =
          servicePerEndpoint.setUserProfile(self.SetUserProfile.Args(userProfile))
        def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): Future[Boolean] =
          servicePerEndpoint.setUserProfiles(self.SetUserProfiles.Args(userProfiles))

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  object ReqRepMethodPerEndpoint {

    def apply(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      new ReqRepMethodPerEndpointImpl(servicePerEndpoint) { }

    /**
     * Use `ReqRepMethodPerEndpoint.apply()` instead of this constructor.
     */
    class ReqRepMethodPerEndpointImpl protected (servicePerEndpoint: ReqRepServicePerEndpoint)
      extends MethodPerEndpoint {

        def ping(): Future[String] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Ping.Args())
          servicePerEndpoint.ping(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoard] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetChallengeLeaderBoard.Args(gameId, myUsername, from, to, onlyFriendFromSocial, leaderboardType))
          servicePerEndpoint.getChallengeLeaderBoard(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetChallengeUserRank.Args(gameId, username, onlyFriendFromSocial, leaderboardType))
          servicePerEndpoint.getChallengeUserRank(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetChallengeUserPoint.Args(gameId, username, pointInfo))
          servicePerEndpoint.setChallengeUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetChallengeUserPoints.Args(gameId, userPoints))
          servicePerEndpoint.setChallengeUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetChallengeUserPointIfHighest.Args(gameId, username, pointInfo))
          servicePerEndpoint.setChallengeUserPointIfHighest(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetChallengeUserPointsIfHighest.Args(gameId, userPoints))
          servicePerEndpoint.setChallengeUserPointsIfHighest(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TUserPointResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetChallengeUserPoint.Args(gameId, username, leaderboardType))
          servicePerEndpoint.getChallengeUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetChallengeUserPoints.Args(gameId, usernames, leaderboardType))
          servicePerEndpoint.getChallengeUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DelChallengeUserPoints.Args(gameId, usernames))
          servicePerEndpoint.delChallengeUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def delChallengeUserPoint(gameId: String, username: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DelChallengeUserPoint.Args(gameId, username))
          servicePerEndpoint.delChallengeUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getSocialLeaderBoard(owner: String, from: Int, to: Int): Future[xed.leaderboard.domain.thrift.TLeaderBoard] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetSocialLeaderBoard.Args(owner, from, to))
          servicePerEndpoint.getSocialLeaderBoard(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getSocialUserRank(owner: String, username: String): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetSocialUserRank.Args(owner, username))
          servicePerEndpoint.getSocialUserRank(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetSocialFriendList.Args(owner, friendUserNames))
          servicePerEndpoint.setSocialFriendList(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def addSocialFriend(owner: String, username: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.AddSocialFriend.Args(owner, username))
          servicePerEndpoint.addSocialFriend(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def removeSocialFriend(owner: String, username: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.RemoveSocialFriend.Args(owner, username))
          servicePerEndpoint.removeSocialFriend(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetSocialUserPoint.Args(username, pointInfo))
          servicePerEndpoint.setSocialUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetSocialUserPoints.Args(userPoints))
          servicePerEndpoint.setSocialUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getSocialUserPoint(username: String): Future[xed.leaderboard.domain.thrift.TUserPointResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetSocialUserPoint.Args(username))
          servicePerEndpoint.getSocialUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetSocialUserPoints.Args(usernames))
          servicePerEndpoint.getSocialUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def delSocialUserPoint(username: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DelSocialUserPoint.Args(username))
          servicePerEndpoint.delSocialUserPoint(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DelSocialUserPoints.Args(usernames))
          servicePerEndpoint.delSocialUserPoints(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetUserProfile.Args(userProfile))
          servicePerEndpoint.setUserProfile(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SetUserProfiles.Args(userProfiles))
          servicePerEndpoint.setUserProfiles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  class MethodIface(serviceIface: BaseServiceIface)
    extends FutureIface {
    def ping(): Future[String] =
      serviceIface.ping(self.Ping.Args())
    def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoard] =
      serviceIface.getChallengeLeaderBoard(self.GetChallengeLeaderBoard.Args(gameId, myUsername, from, to, onlyFriendFromSocial, leaderboardType))
    def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] =
      serviceIface.getChallengeUserRank(self.GetChallengeUserRank.Args(gameId, username, onlyFriendFromSocial, leaderboardType))
    def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
      serviceIface.setChallengeUserPoint(self.SetChallengeUserPoint.Args(gameId, username, pointInfo))
    def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
      serviceIface.setChallengeUserPoints(self.SetChallengeUserPoints.Args(gameId, userPoints))
    def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
      serviceIface.setChallengeUserPointIfHighest(self.SetChallengeUserPointIfHighest.Args(gameId, username, pointInfo))
    def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
      serviceIface.setChallengeUserPointsIfHighest(self.SetChallengeUserPointsIfHighest.Args(gameId, userPoints))
    def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TUserPointResp] =
      serviceIface.getChallengeUserPoint(self.GetChallengeUserPoint.Args(gameId, username, leaderboardType))
    def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] =
      serviceIface.getChallengeUserPoints(self.GetChallengeUserPoints.Args(gameId, usernames, leaderboardType))
    def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): Future[Boolean] =
      serviceIface.delChallengeUserPoints(self.DelChallengeUserPoints.Args(gameId, usernames))
    def delChallengeUserPoint(gameId: String, username: String): Future[Boolean] =
      serviceIface.delChallengeUserPoint(self.DelChallengeUserPoint.Args(gameId, username))
    def getSocialLeaderBoard(owner: String, from: Int, to: Int): Future[xed.leaderboard.domain.thrift.TLeaderBoard] =
      serviceIface.getSocialLeaderBoard(self.GetSocialLeaderBoard.Args(owner, from, to))
    def getSocialUserRank(owner: String, username: String): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp] =
      serviceIface.getSocialUserRank(self.GetSocialUserRank.Args(owner, username))
    def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): Future[Boolean] =
      serviceIface.setSocialFriendList(self.SetSocialFriendList.Args(owner, friendUserNames))
    def addSocialFriend(owner: String, username: String): Future[Boolean] =
      serviceIface.addSocialFriend(self.AddSocialFriend.Args(owner, username))
    def removeSocialFriend(owner: String, username: String): Future[Boolean] =
      serviceIface.removeSocialFriend(self.RemoveSocialFriend.Args(owner, username))
    def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean] =
      serviceIface.setSocialUserPoint(self.SetSocialUserPoint.Args(username, pointInfo))
    def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean] =
      serviceIface.setSocialUserPoints(self.SetSocialUserPoints.Args(userPoints))
    def getSocialUserPoint(username: String): Future[xed.leaderboard.domain.thrift.TUserPointResp] =
      serviceIface.getSocialUserPoint(self.GetSocialUserPoint.Args(username))
    def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp] =
      serviceIface.getSocialUserPoints(self.GetSocialUserPoints.Args(usernames))
    def delSocialUserPoint(username: String): Future[Boolean] =
      serviceIface.delSocialUserPoint(self.DelSocialUserPoint.Args(username))
    def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[Boolean] =
      serviceIface.delSocialUserPoints(self.DelSocialUserPoints.Args(usernames))
    def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): Future[Boolean] =
      serviceIface.setUserProfile(self.SetUserProfile.Args(userProfile))
    def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): Future[Boolean] =
      serviceIface.setUserProfiles(self.SetUserProfiles.Args(userProfiles))
  }

  implicit object MethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.MethodPerEndpointBuilder[ServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2018-01-12")
  implicit object ThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ThriftServiceBuilder[ServicePerEndpoint, TLeaderBoardMWService[Future]] {
    def build(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  implicit object ReqRepMethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepMethodPerEndpointBuilder[ReqRepServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use ReqRepMethodPerEndpointBuilder", "2018-01-12")
  implicit object ReqRepThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepThriftServiceBuilder[ReqRepServicePerEndpoint, TLeaderBoardMWService[Future]] {
    def build(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2017-11-07")
  implicit object MethodIfaceBuilder
    extends com.twitter.finagle.thrift.MethodIfaceBuilder[ServiceIface, TLeaderBoardMWService[Future]] {
    def newMethodIface(serviceIface: ServiceIface): MethodIface =
      new MethodIface(serviceIface)
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  trait FutureIface
    extends TLeaderBoardMWService[Future] {
    
    def ping(): Future[String]
    
    def getChallengeLeaderBoard(gameId: String, myUsername: String, from: Int, to: Int, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoard]
    
    def getChallengeUserRank(gameId: String, username: String, onlyFriendFromSocial: Boolean, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
    
    def setChallengeUserPoint(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setChallengeUserPoints(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def setChallengeUserPointIfHighest(gameId: String, username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setChallengeUserPointsIfHighest(gameId: String, userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def getChallengeUserPoint(gameId: String, username: String, leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TUserPointResp]
    
    def getChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String](), leaderboardType: Option[xed.leaderboard.domain.thrift.TLeaderBoardType] = None): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
    
    def delChallengeUserPoints(gameId: String, usernames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def delChallengeUserPoint(gameId: String, username: String): Future[Boolean]
    
    def getSocialLeaderBoard(owner: String, from: Int, to: Int): Future[xed.leaderboard.domain.thrift.TLeaderBoard]
    
    def getSocialUserRank(owner: String, username: String): Future[xed.leaderboard.domain.thrift.TLeaderBoardItemResp]
    
    def setSocialFriendList(owner: String, friendUserNames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def addSocialFriend(owner: String, username: String): Future[Boolean]
    
    def removeSocialFriend(owner: String, username: String): Future[Boolean]
    
    def setSocialUserPoint(username: String, pointInfo: xed.leaderboard.domain.thrift.TPointInfo): Future[Boolean]
    
    def setSocialUserPoints(userPoints: Map[String, xed.leaderboard.domain.thrift.TPointInfo] = Map[String, xed.leaderboard.domain.thrift.TPointInfo]()): Future[Boolean]
    
    def getSocialUserPoint(username: String): Future[xed.leaderboard.domain.thrift.TUserPointResp]
    
    def getSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[xed.leaderboard.domain.thrift.TMultiGetUserPointResp]
    
    def delSocialUserPoint(username: String): Future[Boolean]
    
    def delSocialUserPoints(usernames: Seq[String] = Seq[String]()): Future[Boolean]
    
    def setUserProfile(userProfile: xed.leaderboard.domain.thrift.TShortUserProfile): Future[Boolean]
    
    def setUserProfiles(userProfiles: Seq[xed.leaderboard.domain.thrift.TShortUserProfile] = Seq[xed.leaderboard.domain.thrift.TShortUserProfile]()): Future[Boolean]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      clientParam: RichClientParam)
    extends TLeaderBoardMWService$FinagleClient(service, clientParam)
    with FutureIface
    with MethodPerEndpoint {

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory = Protocols.binaryFactory(),
      serviceName: String = "TLeaderBoardMWService",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver,
      responseClassifier: ctfs.ResponseClassifier = ctfs.ResponseClassifier.Default
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats,
        responseClassifier = responseClassifier
      )
    )

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String,
      stats: com.twitter.finagle.stats.StatsReceiver
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats
      )
    )
  }

  class FinagledService(
      iface: TLeaderBoardMWService[Future],
      serverParam: RichServerParam)
    extends TLeaderBoardMWService$FinagleService(iface, serverParam) {

    @deprecated("Use com.twitter.finagle.thrift.RichServerParam", "2017-08-16")
    def this(
      iface: TLeaderBoardMWService[Future],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String = "TLeaderBoardMWService"
    ) = this(iface, RichServerParam(protocolFactory, serviceName))
  }
}
