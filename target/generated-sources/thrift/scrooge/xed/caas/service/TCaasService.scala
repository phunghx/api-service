/**
 * Generated by Scrooge
 *   version: 18.4.0
 *   rev: b64bcb47af2451b2e51a1ed1b3876f6c06c642b3
 *   built at: 20180410-144307
 */
package xed.caas.service

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob,
  ThriftService,
  ThriftStruct,
  ThriftStructCodec,
  ThriftStructFieldInfo,
  ThriftResponse,
  ThriftUtil,
  ToThriftService,
  ValidatingThriftStruct,
  ValidatingThriftStructCodec3
}
import com.twitter.finagle.{service => ctfs}
import com.twitter.finagle.thrift.{
  Protocols,
  RichClientParam,
  RichServerParam,
  ThriftClientRequest,
  ThriftServiceIface
}
import com.twitter.util.Future
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait TCaasService[+MM[_]] extends ThriftService {
  
  def ping(): MM[String]
  
  def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): MM[xed.caas.domain.thrift.TUserAuthResult]
  
  def login(username: String, password: String, sessionTimeout: Option[Long] = None): MM[xed.caas.domain.thrift.TUserAuthResult]
  
  def loginOAuth(username: String, sessionTimeout: Option[Long] = None): MM[xed.caas.domain.thrift.TUserAuthResult]
  
  def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): MM[xed.caas.domain.thrift.TUserAuthResult]
  
  def register(username: String, password: String): MM[xed.caas.domain.thrift.TUserInfoResult]
  
  def isCredentialDefault(oauthType: String, username: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def deleteUser(username: String): MM[xed.caas.domain.thrift.TResult]
  
  def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): MM[xed.caas.domain.thrift.TUserInfoResult]
  
  def getUserWithSessionId(sessionId: String): MM[xed.caas.domain.thrift.TUserInfoResult]
  
  def getUserWithUsername(username: String): MM[xed.caas.domain.thrift.TUserInfoResult]
  
  def logout(sessionId: String): MM[xed.caas.domain.thrift.TResult]
  
  def isPermitted(sessionId: String, permission: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TListBoolResult]
  
  def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def isPermittedUser(username: String, permission: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TListBoolResult]
  
  def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def getUserRoles(sessionId: String): MM[xed.caas.domain.thrift.TListStringResult]
  
  def hasRole(sessionId: String, role: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TListBoolResult]
  
  def hasRoleUser(username: String, roleName: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def getAllUsername(): MM[xed.caas.domain.thrift.TListStringResult]
  
  def getActiveUsername(from: Int, size: Int): MM[xed.caas.domain.thrift.TListUserResult]
  
  def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): MM[xed.caas.domain.thrift.TBoolResult]
  
  def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): MM[xed.caas.domain.thrift.TBoolResult]
  
  def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): MM[xed.caas.domain.thrift.TUserInfoPageable]
  
  def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): MM[xed.caas.domain.thrift.TUserInfoPageable]
  
  def resetPasswordUser(username: String, newPassword: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def updatePasswordUser(username: String, oldPassword: String, newPassword: String): MM[xed.caas.domain.thrift.TBoolResult]
  
  def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): MM[xed.caas.domain.thrift.TBoolResult]
  
  def getAllRoleInfo(username: String): MM[xed.caas.domain.thrift.TListRoleInfoResult]
  
  def getAllPermission(username: String): MM[xed.caas.domain.thrift.TListStringResult]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object TCaasService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  trait ServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def renewSession : _root_.com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType]
    def login : _root_.com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType]
    def loginOAuth : _root_.com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType]
    def loginWithOAuth : _root_.com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType]
    def register : _root_.com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType]
    def isCredentialDefault : _root_.com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType]
    def deleteUser : _root_.com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType]
    def registerWithOAuth : _root_.com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType]
    def getUserWithSessionId : _root_.com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType]
    def getUserWithUsername : _root_.com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType]
    def logout : _root_.com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType]
    def isPermitted : _root_.com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType]
    def isPermitteds : _root_.com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType]
    def isPermittedAll : _root_.com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType]
    def isPermittedUser : _root_.com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType]
    def isPermittedsUser : _root_.com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType]
    def isPermittedUserAll : _root_.com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType]
    def getUserRoles : _root_.com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType]
    def hasRole : _root_.com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType]
    def hasRoles : _root_.com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType]
    def hasRoleUser : _root_.com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType]
    def hasAllRoleUser : _root_.com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType]
    def getAllUsername : _root_.com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType]
    def getActiveUsername : _root_.com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType]
    def insertUserRoles : _root_.com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType]
    def insertExpirableUserRoles : _root_.com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType]
    def insertUserRole : _root_.com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType]
    def deleteUserRoles : _root_.com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType]
    def getListUserRole : _root_.com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType]
    def searchListUserRole : _root_.com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType]
    def resetPasswordUser : _root_.com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType]
    def updatePasswordUser : _root_.com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType]
    def deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType]
    def getAllRoleInfo : _root_.com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType]
    def getAllPermission : _root_.com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]

    def withPing(ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]): ServicePerEndpoint = this

    def withRenewSession(renewSession : _root_.com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType]): ServicePerEndpoint = this

    def withLogin(login : _root_.com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType]): ServicePerEndpoint = this

    def withLoginOAuth(loginOAuth : _root_.com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType]): ServicePerEndpoint = this

    def withLoginWithOAuth(loginWithOAuth : _root_.com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType]): ServicePerEndpoint = this

    def withRegister(register : _root_.com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType]): ServicePerEndpoint = this

    def withIsCredentialDefault(isCredentialDefault : _root_.com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType]): ServicePerEndpoint = this

    def withDeleteUser(deleteUser : _root_.com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType]): ServicePerEndpoint = this

    def withRegisterWithOAuth(registerWithOAuth : _root_.com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType]): ServicePerEndpoint = this

    def withGetUserWithSessionId(getUserWithSessionId : _root_.com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType]): ServicePerEndpoint = this

    def withGetUserWithUsername(getUserWithUsername : _root_.com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType]): ServicePerEndpoint = this

    def withLogout(logout : _root_.com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType]): ServicePerEndpoint = this

    def withIsPermitted(isPermitted : _root_.com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType]): ServicePerEndpoint = this

    def withIsPermitteds(isPermitteds : _root_.com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType]): ServicePerEndpoint = this

    def withIsPermittedAll(isPermittedAll : _root_.com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType]): ServicePerEndpoint = this

    def withIsPermittedUser(isPermittedUser : _root_.com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType]): ServicePerEndpoint = this

    def withIsPermittedsUser(isPermittedsUser : _root_.com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType]): ServicePerEndpoint = this

    def withIsPermittedUserAll(isPermittedUserAll : _root_.com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType]): ServicePerEndpoint = this

    def withGetUserRoles(getUserRoles : _root_.com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType]): ServicePerEndpoint = this

    def withHasRole(hasRole : _root_.com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType]): ServicePerEndpoint = this

    def withHasRoles(hasRoles : _root_.com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType]): ServicePerEndpoint = this

    def withHasRoleUser(hasRoleUser : _root_.com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType]): ServicePerEndpoint = this

    def withHasAllRoleUser(hasAllRoleUser : _root_.com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType]): ServicePerEndpoint = this

    def withGetAllUsername(getAllUsername : _root_.com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType]): ServicePerEndpoint = this

    def withGetActiveUsername(getActiveUsername : _root_.com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType]): ServicePerEndpoint = this

    def withInsertUserRoles(insertUserRoles : _root_.com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType]): ServicePerEndpoint = this

    def withInsertExpirableUserRoles(insertExpirableUserRoles : _root_.com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType]): ServicePerEndpoint = this

    def withInsertUserRole(insertUserRole : _root_.com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType]): ServicePerEndpoint = this

    def withDeleteUserRoles(deleteUserRoles : _root_.com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType]): ServicePerEndpoint = this

    def withGetListUserRole(getListUserRole : _root_.com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType]): ServicePerEndpoint = this

    def withSearchListUserRole(searchListUserRole : _root_.com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType]): ServicePerEndpoint = this

    def withResetPasswordUser(resetPasswordUser : _root_.com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType]): ServicePerEndpoint = this

    def withUpdatePasswordUser(updatePasswordUser : _root_.com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType]): ServicePerEndpoint = this

    def withDeleteAllExpiredUserRole(deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType]): ServicePerEndpoint = this

    def withGetAllRoleInfo(getAllRoleInfo : _root_.com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType]): ServicePerEndpoint = this

    def withGetAllPermission(getAllPermission : _root_.com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]): ServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = MethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  trait ReqRepServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.service.Filterable[ReqRepServicePerEndpoint] {
    def ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
    def renewSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RenewSession.Args], _root_.com.twitter.scrooge.Response[self.RenewSession.SuccessType]]
    def login : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Login.Args], _root_.com.twitter.scrooge.Response[self.Login.SuccessType]]
    def loginOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginOAuth.SuccessType]]
    def loginWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginWithOAuth.SuccessType]]
    def register : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Register.Args], _root_.com.twitter.scrooge.Response[self.Register.SuccessType]]
    def isCredentialDefault : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsCredentialDefault.Args], _root_.com.twitter.scrooge.Response[self.IsCredentialDefault.SuccessType]]
    def deleteUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUser.Args], _root_.com.twitter.scrooge.Response[self.DeleteUser.SuccessType]]
    def registerWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RegisterWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.RegisterWithOAuth.SuccessType]]
    def getUserWithSessionId : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithSessionId.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithSessionId.SuccessType]]
    def getUserWithUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithUsername.SuccessType]]
    def logout : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Logout.Args], _root_.com.twitter.scrooge.Response[self.Logout.SuccessType]]
    def isPermitted : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitted.Args], _root_.com.twitter.scrooge.Response[self.IsPermitted.SuccessType]]
    def isPermitteds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitteds.Args], _root_.com.twitter.scrooge.Response[self.IsPermitteds.SuccessType]]
    def isPermittedAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedAll.SuccessType]]
    def isPermittedUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUser.SuccessType]]
    def isPermittedsUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedsUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedsUser.SuccessType]]
    def isPermittedUserAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUserAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUserAll.SuccessType]]
    def getUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserRoles.Args], _root_.com.twitter.scrooge.Response[self.GetUserRoles.SuccessType]]
    def hasRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRole.Args], _root_.com.twitter.scrooge.Response[self.HasRole.SuccessType]]
    def hasRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoles.Args], _root_.com.twitter.scrooge.Response[self.HasRoles.SuccessType]]
    def hasRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasRoleUser.SuccessType]]
    def hasAllRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasAllRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasAllRoleUser.SuccessType]]
    def getAllUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllUsername.Args], _root_.com.twitter.scrooge.Response[self.GetAllUsername.SuccessType]]
    def getActiveUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetActiveUsername.Args], _root_.com.twitter.scrooge.Response[self.GetActiveUsername.SuccessType]]
    def insertUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRoles.SuccessType]]
    def insertExpirableUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertExpirableUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertExpirableUserRoles.SuccessType]]
    def insertUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRole.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRole.SuccessType]]
    def deleteUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUserRoles.Args], _root_.com.twitter.scrooge.Response[self.DeleteUserRoles.SuccessType]]
    def getListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetListUserRole.Args], _root_.com.twitter.scrooge.Response[self.GetListUserRole.SuccessType]]
    def searchListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SearchListUserRole.Args], _root_.com.twitter.scrooge.Response[self.SearchListUserRole.SuccessType]]
    def resetPasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ResetPasswordUser.Args], _root_.com.twitter.scrooge.Response[self.ResetPasswordUser.SuccessType]]
    def updatePasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdatePasswordUser.Args], _root_.com.twitter.scrooge.Response[self.UpdatePasswordUser.SuccessType]]
    def deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteAllExpiredUserRole.Args], _root_.com.twitter.scrooge.Response[self.DeleteAllExpiredUserRole.SuccessType]]
    def getAllRoleInfo : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllRoleInfo.Args], _root_.com.twitter.scrooge.Response[self.GetAllRoleInfo.SuccessType]]
    def getAllPermission : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllPermission.Args], _root_.com.twitter.scrooge.Response[self.GetAllPermission.SuccessType]]

    def withPing(ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]): ReqRepServicePerEndpoint = this

    def withRenewSession(renewSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RenewSession.Args], _root_.com.twitter.scrooge.Response[self.RenewSession.SuccessType]]): ReqRepServicePerEndpoint = this

    def withLogin(login : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Login.Args], _root_.com.twitter.scrooge.Response[self.Login.SuccessType]]): ReqRepServicePerEndpoint = this

    def withLoginOAuth(loginOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginOAuth.SuccessType]]): ReqRepServicePerEndpoint = this

    def withLoginWithOAuth(loginWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginWithOAuth.SuccessType]]): ReqRepServicePerEndpoint = this

    def withRegister(register : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Register.Args], _root_.com.twitter.scrooge.Response[self.Register.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsCredentialDefault(isCredentialDefault : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsCredentialDefault.Args], _root_.com.twitter.scrooge.Response[self.IsCredentialDefault.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDeleteUser(deleteUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUser.Args], _root_.com.twitter.scrooge.Response[self.DeleteUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withRegisterWithOAuth(registerWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RegisterWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.RegisterWithOAuth.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserWithSessionId(getUserWithSessionId : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithSessionId.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithSessionId.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserWithUsername(getUserWithUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithUsername.SuccessType]]): ReqRepServicePerEndpoint = this

    def withLogout(logout : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Logout.Args], _root_.com.twitter.scrooge.Response[self.Logout.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermitted(isPermitted : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitted.Args], _root_.com.twitter.scrooge.Response[self.IsPermitted.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermitteds(isPermitteds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitteds.Args], _root_.com.twitter.scrooge.Response[self.IsPermitteds.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermittedAll(isPermittedAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedAll.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermittedUser(isPermittedUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermittedsUser(isPermittedsUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedsUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedsUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIsPermittedUserAll(isPermittedUserAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUserAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUserAll.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetUserRoles(getUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserRoles.Args], _root_.com.twitter.scrooge.Response[self.GetUserRoles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withHasRole(hasRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRole.Args], _root_.com.twitter.scrooge.Response[self.HasRole.SuccessType]]): ReqRepServicePerEndpoint = this

    def withHasRoles(hasRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoles.Args], _root_.com.twitter.scrooge.Response[self.HasRoles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withHasRoleUser(hasRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasRoleUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withHasAllRoleUser(hasAllRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasAllRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasAllRoleUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetAllUsername(getAllUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllUsername.Args], _root_.com.twitter.scrooge.Response[self.GetAllUsername.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetActiveUsername(getActiveUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetActiveUsername.Args], _root_.com.twitter.scrooge.Response[self.GetActiveUsername.SuccessType]]): ReqRepServicePerEndpoint = this

    def withInsertUserRoles(insertUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRoles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withInsertExpirableUserRoles(insertExpirableUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertExpirableUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertExpirableUserRoles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withInsertUserRole(insertUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRole.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRole.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDeleteUserRoles(deleteUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUserRoles.Args], _root_.com.twitter.scrooge.Response[self.DeleteUserRoles.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetListUserRole(getListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetListUserRole.Args], _root_.com.twitter.scrooge.Response[self.GetListUserRole.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSearchListUserRole(searchListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SearchListUserRole.Args], _root_.com.twitter.scrooge.Response[self.SearchListUserRole.SuccessType]]): ReqRepServicePerEndpoint = this

    def withResetPasswordUser(resetPasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ResetPasswordUser.Args], _root_.com.twitter.scrooge.Response[self.ResetPasswordUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withUpdatePasswordUser(updatePasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdatePasswordUser.Args], _root_.com.twitter.scrooge.Response[self.UpdatePasswordUser.SuccessType]]): ReqRepServicePerEndpoint = this

    def withDeleteAllExpiredUserRole(deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteAllExpiredUserRole.Args], _root_.com.twitter.scrooge.Response[self.DeleteAllExpiredUserRole.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetAllRoleInfo(getAllRoleInfo : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllRoleInfo.Args], _root_.com.twitter.scrooge.Response[self.GetAllRoleInfo.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetAllPermission(getAllPermission : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllPermission.Args], _root_.com.twitter.scrooge.Response[self.GetAllPermission.SuccessType]]): ReqRepServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `ThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: ThriftService = ReqRepMethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  trait BaseServiceIface extends ToThriftService {
    def ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
    def renewSession : com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType]
    def login : com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType]
    def loginOAuth : com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType]
    def loginWithOAuth : com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType]
    def register : com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType]
    def isCredentialDefault : com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType]
    def deleteUser : com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType]
    def registerWithOAuth : com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType]
    def getUserWithSessionId : com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType]
    def getUserWithUsername : com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType]
    def logout : com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType]
    def isPermitted : com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType]
    def isPermitteds : com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType]
    def isPermittedAll : com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType]
    def isPermittedUser : com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType]
    def isPermittedsUser : com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType]
    def isPermittedUserAll : com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType]
    def getUserRoles : com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType]
    def hasRole : com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType]
    def hasRoles : com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType]
    def hasRoleUser : com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType]
    def hasAllRoleUser : com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType]
    def getAllUsername : com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType]
    def getActiveUsername : com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType]
    def insertUserRoles : com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType]
    def insertExpirableUserRoles : com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType]
    def insertUserRole : com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType]
    def deleteUserRoles : com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType]
    def getListUserRole : com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType]
    def searchListUserRole : com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType]
    def resetPasswordUser : com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType]
    def updatePasswordUser : com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType]
    def deleteAllExpiredUserRole : com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType]
    def getAllRoleInfo : com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType]
    def getAllPermission : com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]

    def toThriftService: ThriftService = new MethodIface(this)
  }

  object ServicePerEndpoint {

    def apply(
      ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      renewSession : _root_.com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType],
      login : _root_.com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType],
      loginOAuth : _root_.com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType],
      loginWithOAuth : _root_.com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType],
      register : _root_.com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType],
      isCredentialDefault : _root_.com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType],
      deleteUser : _root_.com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType],
      registerWithOAuth : _root_.com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType],
      getUserWithSessionId : _root_.com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType],
      getUserWithUsername : _root_.com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType],
      logout : _root_.com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType],
      isPermitted : _root_.com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType],
      isPermitteds : _root_.com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType],
      isPermittedAll : _root_.com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType],
      isPermittedUser : _root_.com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType],
      isPermittedsUser : _root_.com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType],
      isPermittedUserAll : _root_.com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType],
      getUserRoles : _root_.com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType],
      hasRole : _root_.com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType],
      hasRoles : _root_.com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType],
      hasRoleUser : _root_.com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType],
      hasAllRoleUser : _root_.com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType],
      getAllUsername : _root_.com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType],
      getActiveUsername : _root_.com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType],
      insertUserRoles : _root_.com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType],
      insertExpirableUserRoles : _root_.com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType],
      insertUserRole : _root_.com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType],
      deleteUserRoles : _root_.com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType],
      getListUserRole : _root_.com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType],
      searchListUserRole : _root_.com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType],
      resetPasswordUser : _root_.com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType],
      updatePasswordUser : _root_.com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType],
      deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType],
      getAllRoleInfo : _root_.com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType],
      getAllPermission : _root_.com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]
    ): ServicePerEndpoint = new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

    private final class ServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
      override val renewSession : _root_.com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType],
      override val login : _root_.com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType],
      override val loginOAuth : _root_.com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType],
      override val loginWithOAuth : _root_.com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType],
      override val register : _root_.com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType],
      override val isCredentialDefault : _root_.com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType],
      override val deleteUser : _root_.com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType],
      override val registerWithOAuth : _root_.com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType],
      override val getUserWithSessionId : _root_.com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType],
      override val getUserWithUsername : _root_.com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType],
      override val logout : _root_.com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType],
      override val isPermitted : _root_.com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType],
      override val isPermitteds : _root_.com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType],
      override val isPermittedAll : _root_.com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType],
      override val isPermittedUser : _root_.com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType],
      override val isPermittedsUser : _root_.com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType],
      override val isPermittedUserAll : _root_.com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType],
      override val getUserRoles : _root_.com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType],
      override val hasRole : _root_.com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType],
      override val hasRoles : _root_.com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType],
      override val hasRoleUser : _root_.com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType],
      override val hasAllRoleUser : _root_.com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType],
      override val getAllUsername : _root_.com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType],
      override val getActiveUsername : _root_.com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType],
      override val insertUserRoles : _root_.com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType],
      override val insertExpirableUserRoles : _root_.com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType],
      override val insertUserRole : _root_.com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType],
      override val deleteUserRoles : _root_.com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType],
      override val getListUserRole : _root_.com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType],
      override val searchListUserRole : _root_.com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType],
      override val resetPasswordUser : _root_.com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType],
      override val updatePasswordUser : _root_.com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType],
      override val deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType],
      override val getAllRoleInfo : _root_.com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType],
      override val getAllPermission : _root_.com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]
    ) extends ServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withRenewSession(
        renewSession : _root_.com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withLogin(
        login : _root_.com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withLoginOAuth(
        loginOAuth : _root_.com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withLoginWithOAuth(
        loginWithOAuth : _root_.com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withRegister(
        register : _root_.com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsCredentialDefault(
        isCredentialDefault : _root_.com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withDeleteUser(
        deleteUser : _root_.com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withRegisterWithOAuth(
        registerWithOAuth : _root_.com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetUserWithSessionId(
        getUserWithSessionId : _root_.com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetUserWithUsername(
        getUserWithUsername : _root_.com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withLogout(
        logout : _root_.com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermitted(
        isPermitted : _root_.com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermitteds(
        isPermitteds : _root_.com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermittedAll(
        isPermittedAll : _root_.com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermittedUser(
        isPermittedUser : _root_.com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermittedsUser(
        isPermittedsUser : _root_.com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withIsPermittedUserAll(
        isPermittedUserAll : _root_.com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetUserRoles(
        getUserRoles : _root_.com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withHasRole(
        hasRole : _root_.com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withHasRoles(
        hasRoles : _root_.com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withHasRoleUser(
        hasRoleUser : _root_.com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withHasAllRoleUser(
        hasAllRoleUser : _root_.com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetAllUsername(
        getAllUsername : _root_.com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetActiveUsername(
        getActiveUsername : _root_.com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withInsertUserRoles(
        insertUserRoles : _root_.com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withInsertExpirableUserRoles(
        insertExpirableUserRoles : _root_.com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withInsertUserRole(
        insertUserRole : _root_.com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withDeleteUserRoles(
        deleteUserRoles : _root_.com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetListUserRole(
        getListUserRole : _root_.com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withSearchListUserRole(
        searchListUserRole : _root_.com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withResetPasswordUser(
        resetPasswordUser : _root_.com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withUpdatePasswordUser(
        updatePasswordUser : _root_.com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withDeleteAllExpiredUserRole(
        deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetAllRoleInfo(
        getAllRoleInfo : _root_.com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def withGetAllPermission(
        getAllPermission : _root_.com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint =
        new ServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          renewSession = filter.toFilter.andThen(renewSession),
          login = filter.toFilter.andThen(login),
          loginOAuth = filter.toFilter.andThen(loginOAuth),
          loginWithOAuth = filter.toFilter.andThen(loginWithOAuth),
          register = filter.toFilter.andThen(register),
          isCredentialDefault = filter.toFilter.andThen(isCredentialDefault),
          deleteUser = filter.toFilter.andThen(deleteUser),
          registerWithOAuth = filter.toFilter.andThen(registerWithOAuth),
          getUserWithSessionId = filter.toFilter.andThen(getUserWithSessionId),
          getUserWithUsername = filter.toFilter.andThen(getUserWithUsername),
          logout = filter.toFilter.andThen(logout),
          isPermitted = filter.toFilter.andThen(isPermitted),
          isPermitteds = filter.toFilter.andThen(isPermitteds),
          isPermittedAll = filter.toFilter.andThen(isPermittedAll),
          isPermittedUser = filter.toFilter.andThen(isPermittedUser),
          isPermittedsUser = filter.toFilter.andThen(isPermittedsUser),
          isPermittedUserAll = filter.toFilter.andThen(isPermittedUserAll),
          getUserRoles = filter.toFilter.andThen(getUserRoles),
          hasRole = filter.toFilter.andThen(hasRole),
          hasRoles = filter.toFilter.andThen(hasRoles),
          hasRoleUser = filter.toFilter.andThen(hasRoleUser),
          hasAllRoleUser = filter.toFilter.andThen(hasAllRoleUser),
          getAllUsername = filter.toFilter.andThen(getAllUsername),
          getActiveUsername = filter.toFilter.andThen(getActiveUsername),
          insertUserRoles = filter.toFilter.andThen(insertUserRoles),
          insertExpirableUserRoles = filter.toFilter.andThen(insertExpirableUserRoles),
          insertUserRole = filter.toFilter.andThen(insertUserRole),
          deleteUserRoles = filter.toFilter.andThen(deleteUserRoles),
          getListUserRole = filter.toFilter.andThen(getListUserRole),
          searchListUserRole = filter.toFilter.andThen(searchListUserRole),
          resetPasswordUser = filter.toFilter.andThen(resetPasswordUser),
          updatePasswordUser = filter.toFilter.andThen(updatePasswordUser),
          deleteAllExpiredUserRole = filter.toFilter.andThen(deleteAllExpiredUserRole),
          getAllRoleInfo = filter.toFilter.andThen(getAllRoleInfo),
          getAllPermission = filter.toFilter.andThen(getAllPermission)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.renewSession,
          this.login,
          this.loginOAuth,
          this.loginWithOAuth,
          this.register,
          this.isCredentialDefault,
          this.deleteUser,
          this.registerWithOAuth,
          this.getUserWithSessionId,
          this.getUserWithUsername,
          this.logout,
          this.isPermitted,
          this.isPermitteds,
          this.isPermittedAll,
          this.isPermittedUser,
          this.isPermittedsUser,
          this.isPermittedUserAll,
          this.getUserRoles,
          this.hasRole,
          this.hasRoles,
          this.hasRoleUser,
          this.hasAllRoleUser,
          this.getAllUsername,
          this.getActiveUsername,
          this.insertUserRoles,
          this.insertExpirableUserRoles,
          this.insertUserRole,
          this.deleteUserRoles,
          this.getListUserRole,
          this.searchListUserRole,
          this.resetPasswordUser,
          this.updatePasswordUser,
          this.deleteAllExpiredUserRole,
          this.getAllRoleInfo,
          this.getAllPermission
        )
    }
  }

  object ReqRepServicePerEndpoint {

    def apply(
      ping :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      renewSession :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RenewSession.Args], _root_.com.twitter.scrooge.Response[self.RenewSession.SuccessType]],
      login :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Login.Args], _root_.com.twitter.scrooge.Response[self.Login.SuccessType]],
      loginOAuth :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LoginOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginOAuth.SuccessType]],
      loginWithOAuth :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LoginWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginWithOAuth.SuccessType]],
      register :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Register.Args], _root_.com.twitter.scrooge.Response[self.Register.SuccessType]],
      isCredentialDefault :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsCredentialDefault.Args], _root_.com.twitter.scrooge.Response[self.IsCredentialDefault.SuccessType]],
      deleteUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteUser.Args], _root_.com.twitter.scrooge.Response[self.DeleteUser.SuccessType]],
      registerWithOAuth :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RegisterWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.RegisterWithOAuth.SuccessType]],
      getUserWithSessionId :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserWithSessionId.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithSessionId.SuccessType]],
      getUserWithUsername :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserWithUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithUsername.SuccessType]],
      logout :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Logout.Args], _root_.com.twitter.scrooge.Response[self.Logout.SuccessType]],
      isPermitted :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermitted.Args], _root_.com.twitter.scrooge.Response[self.IsPermitted.SuccessType]],
      isPermitteds :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermitteds.Args], _root_.com.twitter.scrooge.Response[self.IsPermitteds.SuccessType]],
      isPermittedAll :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedAll.SuccessType]],
      isPermittedUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUser.SuccessType]],
      isPermittedsUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedsUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedsUser.SuccessType]],
      isPermittedUserAll :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedUserAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUserAll.SuccessType]],
      getUserRoles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserRoles.Args], _root_.com.twitter.scrooge.Response[self.GetUserRoles.SuccessType]],
      hasRole :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRole.Args], _root_.com.twitter.scrooge.Response[self.HasRole.SuccessType]],
      hasRoles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRoles.Args], _root_.com.twitter.scrooge.Response[self.HasRoles.SuccessType]],
      hasRoleUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasRoleUser.SuccessType]],
      hasAllRoleUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasAllRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasAllRoleUser.SuccessType]],
      getAllUsername :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllUsername.Args], _root_.com.twitter.scrooge.Response[self.GetAllUsername.SuccessType]],
      getActiveUsername :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetActiveUsername.Args], _root_.com.twitter.scrooge.Response[self.GetActiveUsername.SuccessType]],
      insertUserRoles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRoles.SuccessType]],
      insertExpirableUserRoles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertExpirableUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertExpirableUserRoles.SuccessType]],
      insertUserRole :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertUserRole.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRole.SuccessType]],
      deleteUserRoles :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteUserRoles.Args], _root_.com.twitter.scrooge.Response[self.DeleteUserRoles.SuccessType]],
      getListUserRole :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetListUserRole.Args], _root_.com.twitter.scrooge.Response[self.GetListUserRole.SuccessType]],
      searchListUserRole :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SearchListUserRole.Args], _root_.com.twitter.scrooge.Response[self.SearchListUserRole.SuccessType]],
      resetPasswordUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ResetPasswordUser.Args], _root_.com.twitter.scrooge.Response[self.ResetPasswordUser.SuccessType]],
      updatePasswordUser :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdatePasswordUser.Args], _root_.com.twitter.scrooge.Response[self.UpdatePasswordUser.SuccessType]],
      deleteAllExpiredUserRole :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteAllExpiredUserRole.Args], _root_.com.twitter.scrooge.Response[self.DeleteAllExpiredUserRole.SuccessType]],
      getAllRoleInfo :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllRoleInfo.Args], _root_.com.twitter.scrooge.Response[self.GetAllRoleInfo.SuccessType]],
      getAllPermission :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllPermission.Args], _root_.com.twitter.scrooge.Response[self.GetAllPermission.SuccessType]]
    ): ReqRepServicePerEndpoint =
      new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

    private final class ReqRepServicePerEndpointImpl(
      override val ping : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]],
      override val renewSession : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RenewSession.Args], _root_.com.twitter.scrooge.Response[self.RenewSession.SuccessType]],
      override val login : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Login.Args], _root_.com.twitter.scrooge.Response[self.Login.SuccessType]],
      override val loginOAuth : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LoginOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginOAuth.SuccessType]],
      override val loginWithOAuth : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LoginWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginWithOAuth.SuccessType]],
      override val register : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Register.Args], _root_.com.twitter.scrooge.Response[self.Register.SuccessType]],
      override val isCredentialDefault : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsCredentialDefault.Args], _root_.com.twitter.scrooge.Response[self.IsCredentialDefault.SuccessType]],
      override val deleteUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteUser.Args], _root_.com.twitter.scrooge.Response[self.DeleteUser.SuccessType]],
      override val registerWithOAuth : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RegisterWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.RegisterWithOAuth.SuccessType]],
      override val getUserWithSessionId : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserWithSessionId.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithSessionId.SuccessType]],
      override val getUserWithUsername : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserWithUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithUsername.SuccessType]],
      override val logout : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.Logout.Args], _root_.com.twitter.scrooge.Response[self.Logout.SuccessType]],
      override val isPermitted : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermitted.Args], _root_.com.twitter.scrooge.Response[self.IsPermitted.SuccessType]],
      override val isPermitteds : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermitteds.Args], _root_.com.twitter.scrooge.Response[self.IsPermitteds.SuccessType]],
      override val isPermittedAll : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedAll.SuccessType]],
      override val isPermittedUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUser.SuccessType]],
      override val isPermittedsUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedsUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedsUser.SuccessType]],
      override val isPermittedUserAll : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IsPermittedUserAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUserAll.SuccessType]],
      override val getUserRoles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetUserRoles.Args], _root_.com.twitter.scrooge.Response[self.GetUserRoles.SuccessType]],
      override val hasRole : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRole.Args], _root_.com.twitter.scrooge.Response[self.HasRole.SuccessType]],
      override val hasRoles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRoles.Args], _root_.com.twitter.scrooge.Response[self.HasRoles.SuccessType]],
      override val hasRoleUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasRoleUser.SuccessType]],
      override val hasAllRoleUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.HasAllRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasAllRoleUser.SuccessType]],
      override val getAllUsername : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllUsername.Args], _root_.com.twitter.scrooge.Response[self.GetAllUsername.SuccessType]],
      override val getActiveUsername : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetActiveUsername.Args], _root_.com.twitter.scrooge.Response[self.GetActiveUsername.SuccessType]],
      override val insertUserRoles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRoles.SuccessType]],
      override val insertExpirableUserRoles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertExpirableUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertExpirableUserRoles.SuccessType]],
      override val insertUserRole : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.InsertUserRole.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRole.SuccessType]],
      override val deleteUserRoles : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteUserRoles.Args], _root_.com.twitter.scrooge.Response[self.DeleteUserRoles.SuccessType]],
      override val getListUserRole : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetListUserRole.Args], _root_.com.twitter.scrooge.Response[self.GetListUserRole.SuccessType]],
      override val searchListUserRole : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SearchListUserRole.Args], _root_.com.twitter.scrooge.Response[self.SearchListUserRole.SuccessType]],
      override val resetPasswordUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ResetPasswordUser.Args], _root_.com.twitter.scrooge.Response[self.ResetPasswordUser.SuccessType]],
      override val updatePasswordUser : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdatePasswordUser.Args], _root_.com.twitter.scrooge.Response[self.UpdatePasswordUser.SuccessType]],
      override val deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.DeleteAllExpiredUserRole.Args], _root_.com.twitter.scrooge.Response[self.DeleteAllExpiredUserRole.SuccessType]],
      override val getAllRoleInfo : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllRoleInfo.Args], _root_.com.twitter.scrooge.Response[self.GetAllRoleInfo.SuccessType]],
      override val getAllPermission : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetAllPermission.Args], _root_.com.twitter.scrooge.Response[self.GetAllPermission.SuccessType]]
    ) extends ReqRepServicePerEndpoint {

      override def withPing(
        ping : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Ping.Args], _root_.com.twitter.scrooge.Response[self.Ping.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withRenewSession(
        renewSession : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RenewSession.Args], _root_.com.twitter.scrooge.Response[self.RenewSession.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withLogin(
        login : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Login.Args], _root_.com.twitter.scrooge.Response[self.Login.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withLoginOAuth(
        loginOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginOAuth.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withLoginWithOAuth(
        loginWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LoginWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.LoginWithOAuth.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withRegister(
        register : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Register.Args], _root_.com.twitter.scrooge.Response[self.Register.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsCredentialDefault(
        isCredentialDefault : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsCredentialDefault.Args], _root_.com.twitter.scrooge.Response[self.IsCredentialDefault.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withDeleteUser(
        deleteUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUser.Args], _root_.com.twitter.scrooge.Response[self.DeleteUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withRegisterWithOAuth(
        registerWithOAuth : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RegisterWithOAuth.Args], _root_.com.twitter.scrooge.Response[self.RegisterWithOAuth.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetUserWithSessionId(
        getUserWithSessionId : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithSessionId.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithSessionId.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetUserWithUsername(
        getUserWithUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserWithUsername.Args], _root_.com.twitter.scrooge.Response[self.GetUserWithUsername.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withLogout(
        logout : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.Logout.Args], _root_.com.twitter.scrooge.Response[self.Logout.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermitted(
        isPermitted : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitted.Args], _root_.com.twitter.scrooge.Response[self.IsPermitted.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermitteds(
        isPermitteds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermitteds.Args], _root_.com.twitter.scrooge.Response[self.IsPermitteds.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermittedAll(
        isPermittedAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedAll.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermittedUser(
        isPermittedUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermittedsUser(
        isPermittedsUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedsUser.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedsUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withIsPermittedUserAll(
        isPermittedUserAll : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IsPermittedUserAll.Args], _root_.com.twitter.scrooge.Response[self.IsPermittedUserAll.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetUserRoles(
        getUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetUserRoles.Args], _root_.com.twitter.scrooge.Response[self.GetUserRoles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withHasRole(
        hasRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRole.Args], _root_.com.twitter.scrooge.Response[self.HasRole.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withHasRoles(
        hasRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoles.Args], _root_.com.twitter.scrooge.Response[self.HasRoles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withHasRoleUser(
        hasRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasRoleUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withHasAllRoleUser(
        hasAllRoleUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.HasAllRoleUser.Args], _root_.com.twitter.scrooge.Response[self.HasAllRoleUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetAllUsername(
        getAllUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllUsername.Args], _root_.com.twitter.scrooge.Response[self.GetAllUsername.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetActiveUsername(
        getActiveUsername : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetActiveUsername.Args], _root_.com.twitter.scrooge.Response[self.GetActiveUsername.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withInsertUserRoles(
        insertUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRoles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withInsertExpirableUserRoles(
        insertExpirableUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertExpirableUserRoles.Args], _root_.com.twitter.scrooge.Response[self.InsertExpirableUserRoles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withInsertUserRole(
        insertUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.InsertUserRole.Args], _root_.com.twitter.scrooge.Response[self.InsertUserRole.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withDeleteUserRoles(
        deleteUserRoles : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteUserRoles.Args], _root_.com.twitter.scrooge.Response[self.DeleteUserRoles.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetListUserRole(
        getListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetListUserRole.Args], _root_.com.twitter.scrooge.Response[self.GetListUserRole.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withSearchListUserRole(
        searchListUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SearchListUserRole.Args], _root_.com.twitter.scrooge.Response[self.SearchListUserRole.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withResetPasswordUser(
        resetPasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ResetPasswordUser.Args], _root_.com.twitter.scrooge.Response[self.ResetPasswordUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withUpdatePasswordUser(
        updatePasswordUser : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdatePasswordUser.Args], _root_.com.twitter.scrooge.Response[self.UpdatePasswordUser.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withDeleteAllExpiredUserRole(
        deleteAllExpiredUserRole : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.DeleteAllExpiredUserRole.Args], _root_.com.twitter.scrooge.Response[self.DeleteAllExpiredUserRole.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetAllRoleInfo(
        getAllRoleInfo : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllRoleInfo.Args], _root_.com.twitter.scrooge.Response[self.GetAllRoleInfo.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)
      override def withGetAllPermission(
        getAllPermission : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetAllPermission.Args], _root_.com.twitter.scrooge.Response[self.GetAllPermission.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(ping, renewSession, login, loginOAuth, loginWithOAuth, register, isCredentialDefault, deleteUser, registerWithOAuth, getUserWithSessionId, getUserWithUsername, logout, isPermitted, isPermitteds, isPermittedAll, isPermittedUser, isPermittedsUser, isPermittedUserAll, getUserRoles, hasRole, hasRoles, hasRoleUser, hasAllRoleUser, getAllUsername, getActiveUsername, insertUserRoles, insertExpirableUserRoles, insertUserRole, deleteUserRoles, getListUserRole, searchListUserRole, resetPasswordUser, updatePasswordUser, deleteAllExpiredUserRole, getAllRoleInfo, getAllPermission)

      override def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(
          ping = filter.toFilter.andThen(ping),
          renewSession = filter.toFilter.andThen(renewSession),
          login = filter.toFilter.andThen(login),
          loginOAuth = filter.toFilter.andThen(loginOAuth),
          loginWithOAuth = filter.toFilter.andThen(loginWithOAuth),
          register = filter.toFilter.andThen(register),
          isCredentialDefault = filter.toFilter.andThen(isCredentialDefault),
          deleteUser = filter.toFilter.andThen(deleteUser),
          registerWithOAuth = filter.toFilter.andThen(registerWithOAuth),
          getUserWithSessionId = filter.toFilter.andThen(getUserWithSessionId),
          getUserWithUsername = filter.toFilter.andThen(getUserWithUsername),
          logout = filter.toFilter.andThen(logout),
          isPermitted = filter.toFilter.andThen(isPermitted),
          isPermitteds = filter.toFilter.andThen(isPermitteds),
          isPermittedAll = filter.toFilter.andThen(isPermittedAll),
          isPermittedUser = filter.toFilter.andThen(isPermittedUser),
          isPermittedsUser = filter.toFilter.andThen(isPermittedsUser),
          isPermittedUserAll = filter.toFilter.andThen(isPermittedUserAll),
          getUserRoles = filter.toFilter.andThen(getUserRoles),
          hasRole = filter.toFilter.andThen(hasRole),
          hasRoles = filter.toFilter.andThen(hasRoles),
          hasRoleUser = filter.toFilter.andThen(hasRoleUser),
          hasAllRoleUser = filter.toFilter.andThen(hasAllRoleUser),
          getAllUsername = filter.toFilter.andThen(getAllUsername),
          getActiveUsername = filter.toFilter.andThen(getActiveUsername),
          insertUserRoles = filter.toFilter.andThen(insertUserRoles),
          insertExpirableUserRoles = filter.toFilter.andThen(insertExpirableUserRoles),
          insertUserRole = filter.toFilter.andThen(insertUserRole),
          deleteUserRoles = filter.toFilter.andThen(deleteUserRoles),
          getListUserRole = filter.toFilter.andThen(getListUserRole),
          searchListUserRole = filter.toFilter.andThen(searchListUserRole),
          resetPasswordUser = filter.toFilter.andThen(resetPasswordUser),
          updatePasswordUser = filter.toFilter.andThen(updatePasswordUser),
          deleteAllExpiredUserRole = filter.toFilter.andThen(deleteAllExpiredUserRole),
          getAllRoleInfo = filter.toFilter.andThen(getAllRoleInfo),
          getAllPermission = filter.toFilter.andThen(getAllPermission)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.ping,
          this.renewSession,
          this.login,
          this.loginOAuth,
          this.loginWithOAuth,
          this.register,
          this.isCredentialDefault,
          this.deleteUser,
          this.registerWithOAuth,
          this.getUserWithSessionId,
          this.getUserWithUsername,
          this.logout,
          this.isPermitted,
          this.isPermitteds,
          this.isPermittedAll,
          this.isPermittedUser,
          this.isPermittedsUser,
          this.isPermittedUserAll,
          this.getUserRoles,
          this.hasRole,
          this.hasRoles,
          this.hasRoleUser,
          this.hasAllRoleUser,
          this.getAllUsername,
          this.getActiveUsername,
          this.insertUserRoles,
          this.insertExpirableUserRoles,
          this.insertUserRole,
          this.deleteUserRoles,
          this.getListUserRole,
          this.searchListUserRole,
          this.resetPasswordUser,
          this.updatePasswordUser,
          this.deleteAllExpiredUserRole,
          this.getAllRoleInfo,
          this.getAllPermission
        )
    }
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  case class ServiceIface(
    ping : com.twitter.finagle.Service[self.Ping.Args, self.Ping.SuccessType],
    renewSession : com.twitter.finagle.Service[self.RenewSession.Args, self.RenewSession.SuccessType],
    login : com.twitter.finagle.Service[self.Login.Args, self.Login.SuccessType],
    loginOAuth : com.twitter.finagle.Service[self.LoginOAuth.Args, self.LoginOAuth.SuccessType],
    loginWithOAuth : com.twitter.finagle.Service[self.LoginWithOAuth.Args, self.LoginWithOAuth.SuccessType],
    register : com.twitter.finagle.Service[self.Register.Args, self.Register.SuccessType],
    isCredentialDefault : com.twitter.finagle.Service[self.IsCredentialDefault.Args, self.IsCredentialDefault.SuccessType],
    deleteUser : com.twitter.finagle.Service[self.DeleteUser.Args, self.DeleteUser.SuccessType],
    registerWithOAuth : com.twitter.finagle.Service[self.RegisterWithOAuth.Args, self.RegisterWithOAuth.SuccessType],
    getUserWithSessionId : com.twitter.finagle.Service[self.GetUserWithSessionId.Args, self.GetUserWithSessionId.SuccessType],
    getUserWithUsername : com.twitter.finagle.Service[self.GetUserWithUsername.Args, self.GetUserWithUsername.SuccessType],
    logout : com.twitter.finagle.Service[self.Logout.Args, self.Logout.SuccessType],
    isPermitted : com.twitter.finagle.Service[self.IsPermitted.Args, self.IsPermitted.SuccessType],
    isPermitteds : com.twitter.finagle.Service[self.IsPermitteds.Args, self.IsPermitteds.SuccessType],
    isPermittedAll : com.twitter.finagle.Service[self.IsPermittedAll.Args, self.IsPermittedAll.SuccessType],
    isPermittedUser : com.twitter.finagle.Service[self.IsPermittedUser.Args, self.IsPermittedUser.SuccessType],
    isPermittedsUser : com.twitter.finagle.Service[self.IsPermittedsUser.Args, self.IsPermittedsUser.SuccessType],
    isPermittedUserAll : com.twitter.finagle.Service[self.IsPermittedUserAll.Args, self.IsPermittedUserAll.SuccessType],
    getUserRoles : com.twitter.finagle.Service[self.GetUserRoles.Args, self.GetUserRoles.SuccessType],
    hasRole : com.twitter.finagle.Service[self.HasRole.Args, self.HasRole.SuccessType],
    hasRoles : com.twitter.finagle.Service[self.HasRoles.Args, self.HasRoles.SuccessType],
    hasRoleUser : com.twitter.finagle.Service[self.HasRoleUser.Args, self.HasRoleUser.SuccessType],
    hasAllRoleUser : com.twitter.finagle.Service[self.HasAllRoleUser.Args, self.HasAllRoleUser.SuccessType],
    getAllUsername : com.twitter.finagle.Service[self.GetAllUsername.Args, self.GetAllUsername.SuccessType],
    getActiveUsername : com.twitter.finagle.Service[self.GetActiveUsername.Args, self.GetActiveUsername.SuccessType],
    insertUserRoles : com.twitter.finagle.Service[self.InsertUserRoles.Args, self.InsertUserRoles.SuccessType],
    insertExpirableUserRoles : com.twitter.finagle.Service[self.InsertExpirableUserRoles.Args, self.InsertExpirableUserRoles.SuccessType],
    insertUserRole : com.twitter.finagle.Service[self.InsertUserRole.Args, self.InsertUserRole.SuccessType],
    deleteUserRoles : com.twitter.finagle.Service[self.DeleteUserRoles.Args, self.DeleteUserRoles.SuccessType],
    getListUserRole : com.twitter.finagle.Service[self.GetListUserRole.Args, self.GetListUserRole.SuccessType],
    searchListUserRole : com.twitter.finagle.Service[self.SearchListUserRole.Args, self.SearchListUserRole.SuccessType],
    resetPasswordUser : com.twitter.finagle.Service[self.ResetPasswordUser.Args, self.ResetPasswordUser.SuccessType],
    updatePasswordUser : com.twitter.finagle.Service[self.UpdatePasswordUser.Args, self.UpdatePasswordUser.SuccessType],
    deleteAllExpiredUserRole : com.twitter.finagle.Service[self.DeleteAllExpiredUserRole.Args, self.DeleteAllExpiredUserRole.SuccessType],
    getAllRoleInfo : com.twitter.finagle.Service[self.GetAllRoleInfo.Args, self.GetAllRoleInfo.SuccessType],
    getAllPermission : com.twitter.finagle.Service[self.GetAllPermission.Args, self.GetAllPermission.SuccessType]
  ) extends BaseServiceIface
    with com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServiceIface] {

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServiceIface` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ServiceIface =
      copy(
        ping = filter.toFilter.andThen(ping),
        renewSession = filter.toFilter.andThen(renewSession),
        login = filter.toFilter.andThen(login),
        loginOAuth = filter.toFilter.andThen(loginOAuth),
        loginWithOAuth = filter.toFilter.andThen(loginWithOAuth),
        register = filter.toFilter.andThen(register),
        isCredentialDefault = filter.toFilter.andThen(isCredentialDefault),
        deleteUser = filter.toFilter.andThen(deleteUser),
        registerWithOAuth = filter.toFilter.andThen(registerWithOAuth),
        getUserWithSessionId = filter.toFilter.andThen(getUserWithSessionId),
        getUserWithUsername = filter.toFilter.andThen(getUserWithUsername),
        logout = filter.toFilter.andThen(logout),
        isPermitted = filter.toFilter.andThen(isPermitted),
        isPermitteds = filter.toFilter.andThen(isPermitteds),
        isPermittedAll = filter.toFilter.andThen(isPermittedAll),
        isPermittedUser = filter.toFilter.andThen(isPermittedUser),
        isPermittedsUser = filter.toFilter.andThen(isPermittedsUser),
        isPermittedUserAll = filter.toFilter.andThen(isPermittedUserAll),
        getUserRoles = filter.toFilter.andThen(getUserRoles),
        hasRole = filter.toFilter.andThen(hasRole),
        hasRoles = filter.toFilter.andThen(hasRoles),
        hasRoleUser = filter.toFilter.andThen(hasRoleUser),
        hasAllRoleUser = filter.toFilter.andThen(hasAllRoleUser),
        getAllUsername = filter.toFilter.andThen(getAllUsername),
        getActiveUsername = filter.toFilter.andThen(getActiveUsername),
        insertUserRoles = filter.toFilter.andThen(insertUserRoles),
        insertExpirableUserRoles = filter.toFilter.andThen(insertExpirableUserRoles),
        insertUserRole = filter.toFilter.andThen(insertUserRole),
        deleteUserRoles = filter.toFilter.andThen(deleteUserRoles),
        getListUserRole = filter.toFilter.andThen(getListUserRole),
        searchListUserRole = filter.toFilter.andThen(searchListUserRole),
        resetPasswordUser = filter.toFilter.andThen(resetPasswordUser),
        updatePasswordUser = filter.toFilter.andThen(updatePasswordUser),
        deleteAllExpiredUserRole = filter.toFilter.andThen(deleteAllExpiredUserRole),
        getAllRoleInfo = filter.toFilter.andThen(getAllRoleInfo),
        getAllPermission = filter.toFilter.andThen(getAllPermission)
      )
  }

  implicit object ServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ServicePerEndpointBuilder[ServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServicePerEndpoint =
        ServicePerEndpoint(
          ping = ThriftServiceIface(self.Ping, thriftService, clientParam),
          renewSession = ThriftServiceIface(self.RenewSession, thriftService, clientParam),
          login = ThriftServiceIface(self.Login, thriftService, clientParam),
          loginOAuth = ThriftServiceIface(self.LoginOAuth, thriftService, clientParam),
          loginWithOAuth = ThriftServiceIface(self.LoginWithOAuth, thriftService, clientParam),
          register = ThriftServiceIface(self.Register, thriftService, clientParam),
          isCredentialDefault = ThriftServiceIface(self.IsCredentialDefault, thriftService, clientParam),
          deleteUser = ThriftServiceIface(self.DeleteUser, thriftService, clientParam),
          registerWithOAuth = ThriftServiceIface(self.RegisterWithOAuth, thriftService, clientParam),
          getUserWithSessionId = ThriftServiceIface(self.GetUserWithSessionId, thriftService, clientParam),
          getUserWithUsername = ThriftServiceIface(self.GetUserWithUsername, thriftService, clientParam),
          logout = ThriftServiceIface(self.Logout, thriftService, clientParam),
          isPermitted = ThriftServiceIface(self.IsPermitted, thriftService, clientParam),
          isPermitteds = ThriftServiceIface(self.IsPermitteds, thriftService, clientParam),
          isPermittedAll = ThriftServiceIface(self.IsPermittedAll, thriftService, clientParam),
          isPermittedUser = ThriftServiceIface(self.IsPermittedUser, thriftService, clientParam),
          isPermittedsUser = ThriftServiceIface(self.IsPermittedsUser, thriftService, clientParam),
          isPermittedUserAll = ThriftServiceIface(self.IsPermittedUserAll, thriftService, clientParam),
          getUserRoles = ThriftServiceIface(self.GetUserRoles, thriftService, clientParam),
          hasRole = ThriftServiceIface(self.HasRole, thriftService, clientParam),
          hasRoles = ThriftServiceIface(self.HasRoles, thriftService, clientParam),
          hasRoleUser = ThriftServiceIface(self.HasRoleUser, thriftService, clientParam),
          hasAllRoleUser = ThriftServiceIface(self.HasAllRoleUser, thriftService, clientParam),
          getAllUsername = ThriftServiceIface(self.GetAllUsername, thriftService, clientParam),
          getActiveUsername = ThriftServiceIface(self.GetActiveUsername, thriftService, clientParam),
          insertUserRoles = ThriftServiceIface(self.InsertUserRoles, thriftService, clientParam),
          insertExpirableUserRoles = ThriftServiceIface(self.InsertExpirableUserRoles, thriftService, clientParam),
          insertUserRole = ThriftServiceIface(self.InsertUserRole, thriftService, clientParam),
          deleteUserRoles = ThriftServiceIface(self.DeleteUserRoles, thriftService, clientParam),
          getListUserRole = ThriftServiceIface(self.GetListUserRole, thriftService, clientParam),
          searchListUserRole = ThriftServiceIface(self.SearchListUserRole, thriftService, clientParam),
          resetPasswordUser = ThriftServiceIface(self.ResetPasswordUser, thriftService, clientParam),
          updatePasswordUser = ThriftServiceIface(self.UpdatePasswordUser, thriftService, clientParam),
          deleteAllExpiredUserRole = ThriftServiceIface(self.DeleteAllExpiredUserRole, thriftService, clientParam),
          getAllRoleInfo = ThriftServiceIface(self.GetAllRoleInfo, thriftService, clientParam),
          getAllPermission = ThriftServiceIface(self.GetAllPermission, thriftService, clientParam)
        )
  }

  implicit object ReqRepServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepServicePerEndpointBuilder[ReqRepServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ReqRepServicePerEndpoint =
        ReqRepServicePerEndpoint(
          ping = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Ping, thriftService, clientParam),
          renewSession = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.RenewSession, thriftService, clientParam),
          login = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Login, thriftService, clientParam),
          loginOAuth = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.LoginOAuth, thriftService, clientParam),
          loginWithOAuth = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.LoginWithOAuth, thriftService, clientParam),
          register = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Register, thriftService, clientParam),
          isCredentialDefault = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsCredentialDefault, thriftService, clientParam),
          deleteUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DeleteUser, thriftService, clientParam),
          registerWithOAuth = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.RegisterWithOAuth, thriftService, clientParam),
          getUserWithSessionId = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserWithSessionId, thriftService, clientParam),
          getUserWithUsername = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserWithUsername, thriftService, clientParam),
          logout = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.Logout, thriftService, clientParam),
          isPermitted = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermitted, thriftService, clientParam),
          isPermitteds = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermitteds, thriftService, clientParam),
          isPermittedAll = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermittedAll, thriftService, clientParam),
          isPermittedUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermittedUser, thriftService, clientParam),
          isPermittedsUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermittedsUser, thriftService, clientParam),
          isPermittedUserAll = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IsPermittedUserAll, thriftService, clientParam),
          getUserRoles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetUserRoles, thriftService, clientParam),
          hasRole = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.HasRole, thriftService, clientParam),
          hasRoles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.HasRoles, thriftService, clientParam),
          hasRoleUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.HasRoleUser, thriftService, clientParam),
          hasAllRoleUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.HasAllRoleUser, thriftService, clientParam),
          getAllUsername = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetAllUsername, thriftService, clientParam),
          getActiveUsername = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetActiveUsername, thriftService, clientParam),
          insertUserRoles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.InsertUserRoles, thriftService, clientParam),
          insertExpirableUserRoles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.InsertExpirableUserRoles, thriftService, clientParam),
          insertUserRole = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.InsertUserRole, thriftService, clientParam),
          deleteUserRoles = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DeleteUserRoles, thriftService, clientParam),
          getListUserRole = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetListUserRole, thriftService, clientParam),
          searchListUserRole = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SearchListUserRole, thriftService, clientParam),
          resetPasswordUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ResetPasswordUser, thriftService, clientParam),
          updatePasswordUser = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.UpdatePasswordUser, thriftService, clientParam),
          deleteAllExpiredUserRole = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.DeleteAllExpiredUserRole, thriftService, clientParam),
          getAllRoleInfo = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetAllRoleInfo, thriftService, clientParam),
          getAllPermission = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetAllPermission, thriftService, clientParam)
        )
  }

  @deprecated("Use ServicePerEndpointBuilder", "2017-11-07")
  implicit object ServiceIfaceBuilder
    extends com.twitter.finagle.thrift.ServiceIfaceBuilder[ServiceIface] {
      def newServiceIface(
        binaryService: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServiceIface =
        ServiceIface(
          ping = ThriftServiceIface(self.Ping, binaryService, clientParam),
          renewSession = ThriftServiceIface(self.RenewSession, binaryService, clientParam),
          login = ThriftServiceIface(self.Login, binaryService, clientParam),
          loginOAuth = ThriftServiceIface(self.LoginOAuth, binaryService, clientParam),
          loginWithOAuth = ThriftServiceIface(self.LoginWithOAuth, binaryService, clientParam),
          register = ThriftServiceIface(self.Register, binaryService, clientParam),
          isCredentialDefault = ThriftServiceIface(self.IsCredentialDefault, binaryService, clientParam),
          deleteUser = ThriftServiceIface(self.DeleteUser, binaryService, clientParam),
          registerWithOAuth = ThriftServiceIface(self.RegisterWithOAuth, binaryService, clientParam),
          getUserWithSessionId = ThriftServiceIface(self.GetUserWithSessionId, binaryService, clientParam),
          getUserWithUsername = ThriftServiceIface(self.GetUserWithUsername, binaryService, clientParam),
          logout = ThriftServiceIface(self.Logout, binaryService, clientParam),
          isPermitted = ThriftServiceIface(self.IsPermitted, binaryService, clientParam),
          isPermitteds = ThriftServiceIface(self.IsPermitteds, binaryService, clientParam),
          isPermittedAll = ThriftServiceIface(self.IsPermittedAll, binaryService, clientParam),
          isPermittedUser = ThriftServiceIface(self.IsPermittedUser, binaryService, clientParam),
          isPermittedsUser = ThriftServiceIface(self.IsPermittedsUser, binaryService, clientParam),
          isPermittedUserAll = ThriftServiceIface(self.IsPermittedUserAll, binaryService, clientParam),
          getUserRoles = ThriftServiceIface(self.GetUserRoles, binaryService, clientParam),
          hasRole = ThriftServiceIface(self.HasRole, binaryService, clientParam),
          hasRoles = ThriftServiceIface(self.HasRoles, binaryService, clientParam),
          hasRoleUser = ThriftServiceIface(self.HasRoleUser, binaryService, clientParam),
          hasAllRoleUser = ThriftServiceIface(self.HasAllRoleUser, binaryService, clientParam),
          getAllUsername = ThriftServiceIface(self.GetAllUsername, binaryService, clientParam),
          getActiveUsername = ThriftServiceIface(self.GetActiveUsername, binaryService, clientParam),
          insertUserRoles = ThriftServiceIface(self.InsertUserRoles, binaryService, clientParam),
          insertExpirableUserRoles = ThriftServiceIface(self.InsertExpirableUserRoles, binaryService, clientParam),
          insertUserRole = ThriftServiceIface(self.InsertUserRole, binaryService, clientParam),
          deleteUserRoles = ThriftServiceIface(self.DeleteUserRoles, binaryService, clientParam),
          getListUserRole = ThriftServiceIface(self.GetListUserRole, binaryService, clientParam),
          searchListUserRole = ThriftServiceIface(self.SearchListUserRole, binaryService, clientParam),
          resetPasswordUser = ThriftServiceIface(self.ResetPasswordUser, binaryService, clientParam),
          updatePasswordUser = ThriftServiceIface(self.UpdatePasswordUser, binaryService, clientParam),
          deleteAllExpiredUserRole = ThriftServiceIface(self.DeleteAllExpiredUserRole, binaryService, clientParam),
          getAllRoleInfo = ThriftServiceIface(self.GetAllRoleInfo, binaryService, clientParam),
          getAllPermission = ThriftServiceIface(self.GetAllPermission, binaryService, clientParam)
        )
  }

  object Ping extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("ping_result")
      val SuccessField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[String]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product1[Option[String]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[String]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[String]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "ping"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val ping$args = Ping.Args
  type ping$args = Ping.Args

  val ping$result = Ping.Result
  type ping$result = Ping.Result

  object RenewSession extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("renewSession_args")
      val OldSessionIdField = new TField("oldSessionId", TType.STRING, 1)
      val OldSessionIdFieldManifest = implicitly[Manifest[String]]
      val SessionTimeoutField = new TField("sessionTimeout", TType.I64, 2)
      val SessionTimeoutFieldManifest = implicitly[Manifest[Long]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OldSessionIdField,
          false,
          true,
          OldSessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SessionTimeoutField,
          true,
          false,
          SessionTimeoutFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.oldSessionId == null) throw new TProtocolException("Required field oldSessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.oldSessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.oldSessionId)
        buf ++= validateField(item.sessionTimeout)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          oldSessionId =
            {
              val field = original.oldSessionId
              field
            },
          sessionTimeout =
            {
              val field = original.sessionTimeout
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var oldSessionId: String = null
        var _got_oldSessionId = false
        var sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    oldSessionId = readOldSessionIdValue(_iprot)
                    _got_oldSessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'oldSessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I64 =>
                    sessionTimeout = _root_.scala.Some(readSessionTimeoutValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionTimeout' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_oldSessionId) throw new TProtocolException("Required field 'oldSessionId' was not found in serialized data for struct Args")
        new Args(
          oldSessionId,
          sessionTimeout,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        oldSessionId: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ): Args =
        new Args(
          oldSessionId,
          sessionTimeout
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Option[Long]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOldSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOldSessionIdField(oldSessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OldSessionIdField)
        writeOldSessionIdValue(oldSessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOldSessionIdValue(oldSessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(oldSessionId_item)
      }
    
      @inline private[service] def readSessionTimeoutValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeSessionTimeoutField(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionTimeoutField)
        writeSessionTimeoutValue(sessionTimeout_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionTimeoutValue(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(sessionTimeout_item)
      }
    
    
    }
    
    class Args(
        val oldSessionId: String,
        val sessionTimeout: _root_.scala.Option[Long],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Option[Long]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        oldSessionId: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ) = this(
        oldSessionId,
        sessionTimeout,
        Map.empty
      )
    
      def _1 = oldSessionId
      def _2 = sessionTimeout
    
      def toTuple: _root_.scala.Tuple2[String, Option[Long]] = {
        (
          oldSessionId,
          sessionTimeout
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (oldSessionId ne null) writeOldSessionIdField(oldSessionId, _oprot)
        if (sessionTimeout.isDefined) writeSessionTimeoutField(sessionTimeout.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        oldSessionId: String = this.oldSessionId,
        sessionTimeout: _root_.scala.Option[Long] = this.sessionTimeout,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          oldSessionId,
          sessionTimeout,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.oldSessionId
        case 1 => this.sessionTimeout
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserAuthResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("renewSession_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserAuthResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserAuthResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserAuthResult = {
        xed.caas.domain.thrift.TUserAuthResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserAuthResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserAuthResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserAuthResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserAuthResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserAuthResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "renewSession"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val renewSession$args = RenewSession.Args
  type renewSession$args = RenewSession.Args

  val renewSession$result = RenewSession.Result
  type renewSession$result = RenewSession.Result

  object Login extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("login_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PasswordField = new TField("password", TType.STRING, 2)
      val PasswordFieldManifest = implicitly[Manifest[String]]
      val SessionTimeoutField = new TField("sessionTimeout", TType.I64, 3)
      val SessionTimeoutFieldManifest = implicitly[Manifest[Long]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PasswordField,
          false,
          true,
          PasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SessionTimeoutField,
          true,
          false,
          SessionTimeoutFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.password == null) throw new TProtocolException("Required field password cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.password == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.password)
        buf ++= validateField(item.sessionTimeout)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          password =
            {
              val field = original.password
              field
            },
          sessionTimeout =
            {
              val field = original.sessionTimeout
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var password: String = null
        var _got_password = false
        var sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    password = readPasswordValue(_iprot)
                    _got_password = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'password' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I64 =>
                    sessionTimeout = _root_.scala.Some(readSessionTimeoutValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionTimeout' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_password) throw new TProtocolException("Required field 'password' was not found in serialized data for struct Args")
        new Args(
          username,
          password,
          sessionTimeout,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        password: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ): Args =
        new Args(
          username,
          password,
          sessionTimeout
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, String, Option[Long]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePasswordField(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PasswordField)
        writePasswordValue(password_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePasswordValue(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(password_item)
      }
    
      @inline private[service] def readSessionTimeoutValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeSessionTimeoutField(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionTimeoutField)
        writeSessionTimeoutValue(sessionTimeout_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionTimeoutValue(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(sessionTimeout_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val password: String,
        val sessionTimeout: _root_.scala.Option[Long],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, String, Option[Long]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        password: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ) = this(
        username,
        password,
        sessionTimeout,
        Map.empty
      )
    
      def _1 = username
      def _2 = password
      def _3 = sessionTimeout
    
      def toTuple: _root_.scala.Tuple3[String, String, Option[Long]] = {
        (
          username,
          password,
          sessionTimeout
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (password ne null) writePasswordField(password, _oprot)
        if (sessionTimeout.isDefined) writeSessionTimeoutField(sessionTimeout.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        password: String = this.password,
        sessionTimeout: _root_.scala.Option[Long] = this.sessionTimeout,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          password,
          sessionTimeout,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.password
        case 2 => this.sessionTimeout
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserAuthResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("login_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserAuthResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserAuthResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserAuthResult = {
        xed.caas.domain.thrift.TUserAuthResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserAuthResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserAuthResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserAuthResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserAuthResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserAuthResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "login"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val login$args = Login.Args
  type login$args = Login.Args

  val login$result = Login.Result
  type login$result = Login.Result

  object LoginOAuth extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("loginOAuth_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val SessionTimeoutField = new TField("sessionTimeout", TType.I64, 3)
      val SessionTimeoutFieldManifest = implicitly[Manifest[Long]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SessionTimeoutField,
          true,
          false,
          SessionTimeoutFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf ++= validateField(item.sessionTimeout)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          sessionTimeout =
            {
              val field = original.sessionTimeout
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I64 =>
                    sessionTimeout = _root_.scala.Some(readSessionTimeoutValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionTimeout' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          sessionTimeout,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ): Args =
        new Args(
          username,
          sessionTimeout
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Option[Long]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readSessionTimeoutValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeSessionTimeoutField(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionTimeoutField)
        writeSessionTimeoutValue(sessionTimeout_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionTimeoutValue(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(sessionTimeout_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val sessionTimeout: _root_.scala.Option[Long],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Option[Long]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
      ) = this(
        username,
        sessionTimeout,
        Map.empty
      )
    
      def _1 = username
      def _2 = sessionTimeout
    
      def toTuple: _root_.scala.Tuple2[String, Option[Long]] = {
        (
          username,
          sessionTimeout
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (sessionTimeout.isDefined) writeSessionTimeoutField(sessionTimeout.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        sessionTimeout: _root_.scala.Option[Long] = this.sessionTimeout,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          sessionTimeout,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.sessionTimeout
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserAuthResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("loginOAuth_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserAuthResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserAuthResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserAuthResult = {
        xed.caas.domain.thrift.TUserAuthResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserAuthResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserAuthResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserAuthResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserAuthResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserAuthResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "loginOAuth"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val loginOAuth$args = LoginOAuth.Args
  type loginOAuth$args = LoginOAuth.Args

  val loginOAuth$result = LoginOAuth.Result
  type loginOAuth$result = LoginOAuth.Result

  object LoginWithOAuth extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("loginWithOAuth_args")
      val OauthTypeField = new TField("oauthType", TType.STRING, 1)
      val OauthTypeFieldManifest = implicitly[Manifest[String]]
      val IdField = new TField("id", TType.STRING, 2)
      val IdFieldManifest = implicitly[Manifest[String]]
      val TokenField = new TField("token", TType.STRING, 3)
      val TokenFieldManifest = implicitly[Manifest[String]]
      val SessionTimeoutField = new TField("sessionTimeout", TType.I64, 4)
      val SessionTimeoutFieldManifest = implicitly[Manifest[Long]]
      val PasswordField = new TField("password", TType.STRING, 5)
      val PasswordFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OauthTypeField,
          false,
          true,
          OauthTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IdField,
          false,
          true,
          IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          TokenField,
          false,
          true,
          TokenFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SessionTimeoutField,
          true,
          false,
          SessionTimeoutFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PasswordField,
          true,
          false,
          PasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.oauthType == null) throw new TProtocolException("Required field oauthType cannot be null")
        if (_item.id == null) throw new TProtocolException("Required field id cannot be null")
        if (_item.token == null) throw new TProtocolException("Required field token cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.oauthType == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.oauthType)
        if (item.id == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.id)
        if (item.token == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(2))
        buf ++= validateField(item.token)
        buf ++= validateField(item.sessionTimeout)
        buf ++= validateField(item.password)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          oauthType =
            {
              val field = original.oauthType
              field
            },
          id =
            {
              val field = original.id
              field
            },
          token =
            {
              val field = original.token
              field
            },
          sessionTimeout =
            {
              val field = original.sessionTimeout
              field.map { field =>
                field
              }
            },
          password =
            {
              val field = original.password
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var oauthType: String = null
        var _got_oauthType = false
        var id: String = null
        var _got_id = false
        var token: String = null
        var _got_token = false
        var sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None
        var password: _root_.scala.Option[String] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    oauthType = readOauthTypeValue(_iprot)
                    _got_oauthType = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'oauthType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    id = readIdValue(_iprot)
                    _got_id = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    token = readTokenValue(_iprot)
                    _got_token = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'token' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.I64 =>
                    sessionTimeout = _root_.scala.Some(readSessionTimeoutValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionTimeout' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 5 =>
                _field.`type` match {
                  case TType.STRING =>
                    password = _root_.scala.Some(readPasswordValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'password' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_oauthType) throw new TProtocolException("Required field 'oauthType' was not found in serialized data for struct Args")
        if (!_got_id) throw new TProtocolException("Required field 'id' was not found in serialized data for struct Args")
        if (!_got_token) throw new TProtocolException("Required field 'token' was not found in serialized data for struct Args")
        new Args(
          oauthType,
          id,
          token,
          sessionTimeout,
          password,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        oauthType: String,
        id: String,
        token: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None,
        password: _root_.scala.Option[String] = _root_.scala.None
      ): Args =
        new Args(
          oauthType,
          id,
          token,
          sessionTimeout,
          password
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple5[String, String, String, Option[Long], Option[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOauthTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOauthTypeField(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OauthTypeField)
        writeOauthTypeValue(oauthType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOauthTypeValue(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(oauthType_item)
      }
    
      @inline private[service] def readIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeIdField(id_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IdField)
        writeIdValue(id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIdValue(id_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(id_item)
      }
    
      @inline private[service] def readTokenValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeTokenField(token_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TokenField)
        writeTokenValue(token_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTokenValue(token_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(token_item)
      }
    
      @inline private[service] def readSessionTimeoutValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeSessionTimeoutField(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionTimeoutField)
        writeSessionTimeoutValue(sessionTimeout_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionTimeoutValue(sessionTimeout_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(sessionTimeout_item)
      }
    
      @inline private[service] def readPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePasswordField(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PasswordField)
        writePasswordValue(password_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePasswordValue(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(password_item)
      }
    
    
    }
    
    class Args(
        val oauthType: String,
        val id: String,
        val token: String,
        val sessionTimeout: _root_.scala.Option[Long],
        val password: _root_.scala.Option[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product5[String, String, String, Option[Long], Option[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        oauthType: String,
        id: String,
        token: String,
        sessionTimeout: _root_.scala.Option[Long] = _root_.scala.None,
        password: _root_.scala.Option[String] = _root_.scala.None
      ) = this(
        oauthType,
        id,
        token,
        sessionTimeout,
        password,
        Map.empty
      )
    
      def _1 = oauthType
      def _2 = id
      def _3 = token
      def _4 = sessionTimeout
      def _5 = password
    
      def toTuple: _root_.scala.Tuple5[String, String, String, Option[Long], Option[String]] = {
        (
          oauthType,
          id,
          token,
          sessionTimeout,
          password
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (oauthType ne null) writeOauthTypeField(oauthType, _oprot)
        if (id ne null) writeIdField(id, _oprot)
        if (token ne null) writeTokenField(token, _oprot)
        if (sessionTimeout.isDefined) writeSessionTimeoutField(sessionTimeout.get, _oprot)
        if (password.isDefined) writePasswordField(password.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        oauthType: String = this.oauthType,
        id: String = this.id,
        token: String = this.token,
        sessionTimeout: _root_.scala.Option[Long] = this.sessionTimeout,
        password: _root_.scala.Option[String] = this.password,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          oauthType,
          id,
          token,
          sessionTimeout,
          password,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.oauthType
        case 1 => this.id
        case 2 => this.token
        case 3 => this.sessionTimeout
        case 4 => this.password
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserAuthResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("loginWithOAuth_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserAuthResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserAuthResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserAuthResult = {
        xed.caas.domain.thrift.TUserAuthResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserAuthResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserAuthResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserAuthResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserAuthResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserAuthResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserAuthResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserAuthResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "loginWithOAuth"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val loginWithOAuth$args = LoginWithOAuth.Args
  type loginWithOAuth$args = LoginWithOAuth.Args

  val loginWithOAuth$result = LoginWithOAuth.Result
  type loginWithOAuth$result = LoginWithOAuth.Result

  object Register extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("register_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PasswordField = new TField("password", TType.STRING, 2)
      val PasswordFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PasswordField,
          false,
          true,
          PasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.password == null) throw new TProtocolException("Required field password cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.password == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.password)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          password =
            {
              val field = original.password
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var password: String = null
        var _got_password = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    password = readPasswordValue(_iprot)
                    _got_password = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'password' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_password) throw new TProtocolException("Required field 'password' was not found in serialized data for struct Args")
        new Args(
          username,
          password,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        password: String
      ): Args =
        new Args(
          username,
          password
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePasswordField(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PasswordField)
        writePasswordValue(password_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePasswordValue(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(password_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val password: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        password: String
      ) = this(
        username,
        password,
        Map.empty
      )
    
      def _1 = username
      def _2 = password
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          username,
          password
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (password ne null) writePasswordField(password, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        password: String = this.password,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          password,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.password
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("register_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoResult = {
        xed.caas.domain.thrift.TUserInfoResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "register"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val register$args = Register.Args
  type register$args = Register.Args

  val register$result = Register.Result
  type register$result = Register.Result

  object IsCredentialDefault extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isCredentialDefault_args")
      val OauthTypeField = new TField("oauthType", TType.STRING, 1)
      val OauthTypeFieldManifest = implicitly[Manifest[String]]
      val UsernameField = new TField("username", TType.STRING, 2)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OauthTypeField,
          false,
          true,
          OauthTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.oauthType == null) throw new TProtocolException("Required field oauthType cannot be null")
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.oauthType == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.oauthType)
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          oauthType =
            {
              val field = original.oauthType
              field
            },
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var oauthType: String = null
        var _got_oauthType = false
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    oauthType = readOauthTypeValue(_iprot)
                    _got_oauthType = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'oauthType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_oauthType) throw new TProtocolException("Required field 'oauthType' was not found in serialized data for struct Args")
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          oauthType,
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        oauthType: String,
        username: String
      ): Args =
        new Args(
          oauthType,
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOauthTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOauthTypeField(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OauthTypeField)
        writeOauthTypeValue(oauthType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOauthTypeValue(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(oauthType_item)
      }
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val oauthType: String,
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        oauthType: String,
        username: String
      ) = this(
        oauthType,
        username,
        Map.empty
      )
    
      def _1 = oauthType
      def _2 = username
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          oauthType,
          username
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (oauthType ne null) writeOauthTypeField(oauthType, _oprot)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        oauthType: String = this.oauthType,
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          oauthType,
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.oauthType
        case 1 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isCredentialDefault_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isCredentialDefault"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isCredentialDefault$args = IsCredentialDefault.Args
  type isCredentialDefault$args = IsCredentialDefault.Args

  val isCredentialDefault$result = IsCredentialDefault.Result
  type isCredentialDefault$result = IsCredentialDefault.Result

  object DeleteUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TResult = {
        xed.caas.domain.thrift.TResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "deleteUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val deleteUser$args = DeleteUser.Args
  type deleteUser$args = DeleteUser.Args

  val deleteUser$result = DeleteUser.Result
  type deleteUser$result = DeleteUser.Result

  object RegisterWithOAuth extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("registerWithOAuth_args")
      val OauthTypeField = new TField("oauthType", TType.STRING, 1)
      val OauthTypeFieldManifest = implicitly[Manifest[String]]
      val IdField = new TField("id", TType.STRING, 2)
      val IdFieldManifest = implicitly[Manifest[String]]
      val TokenField = new TField("token", TType.STRING, 3)
      val TokenFieldManifest = implicitly[Manifest[String]]
      val PasswordField = new TField("password", TType.STRING, 4)
      val PasswordFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          OauthTypeField,
          false,
          true,
          OauthTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IdField,
          false,
          true,
          IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          TokenField,
          false,
          true,
          TokenFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PasswordField,
          true,
          false,
          PasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.oauthType == null) throw new TProtocolException("Required field oauthType cannot be null")
        if (_item.id == null) throw new TProtocolException("Required field id cannot be null")
        if (_item.token == null) throw new TProtocolException("Required field token cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.oauthType == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.oauthType)
        if (item.id == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.id)
        if (item.token == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(2))
        buf ++= validateField(item.token)
        buf ++= validateField(item.password)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          oauthType =
            {
              val field = original.oauthType
              field
            },
          id =
            {
              val field = original.id
              field
            },
          token =
            {
              val field = original.token
              field
            },
          password =
            {
              val field = original.password
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var oauthType: String = null
        var _got_oauthType = false
        var id: String = null
        var _got_id = false
        var token: String = null
        var _got_token = false
        var password: _root_.scala.Option[String] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    oauthType = readOauthTypeValue(_iprot)
                    _got_oauthType = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'oauthType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    id = readIdValue(_iprot)
                    _got_id = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    token = readTokenValue(_iprot)
                    _got_token = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'token' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    password = _root_.scala.Some(readPasswordValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'password' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_oauthType) throw new TProtocolException("Required field 'oauthType' was not found in serialized data for struct Args")
        if (!_got_id) throw new TProtocolException("Required field 'id' was not found in serialized data for struct Args")
        if (!_got_token) throw new TProtocolException("Required field 'token' was not found in serialized data for struct Args")
        new Args(
          oauthType,
          id,
          token,
          password,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        oauthType: String,
        id: String,
        token: String,
        password: _root_.scala.Option[String] = _root_.scala.None
      ): Args =
        new Args(
          oauthType,
          id,
          token,
          password
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[String, String, String, Option[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readOauthTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOauthTypeField(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OauthTypeField)
        writeOauthTypeValue(oauthType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOauthTypeValue(oauthType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(oauthType_item)
      }
    
      @inline private[service] def readIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeIdField(id_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IdField)
        writeIdValue(id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIdValue(id_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(id_item)
      }
    
      @inline private[service] def readTokenValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeTokenField(token_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TokenField)
        writeTokenValue(token_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTokenValue(token_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(token_item)
      }
    
      @inline private[service] def readPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePasswordField(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PasswordField)
        writePasswordValue(password_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePasswordValue(password_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(password_item)
      }
    
    
    }
    
    class Args(
        val oauthType: String,
        val id: String,
        val token: String,
        val password: _root_.scala.Option[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[String, String, String, Option[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        oauthType: String,
        id: String,
        token: String,
        password: _root_.scala.Option[String] = _root_.scala.None
      ) = this(
        oauthType,
        id,
        token,
        password,
        Map.empty
      )
    
      def _1 = oauthType
      def _2 = id
      def _3 = token
      def _4 = password
    
      def toTuple: _root_.scala.Tuple4[String, String, String, Option[String]] = {
        (
          oauthType,
          id,
          token,
          password
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (oauthType ne null) writeOauthTypeField(oauthType, _oprot)
        if (id ne null) writeIdField(id, _oprot)
        if (token ne null) writeTokenField(token, _oprot)
        if (password.isDefined) writePasswordField(password.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        oauthType: String = this.oauthType,
        id: String = this.id,
        token: String = this.token,
        password: _root_.scala.Option[String] = this.password,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          oauthType,
          id,
          token,
          password,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.oauthType
        case 1 => this.id
        case 2 => this.token
        case 3 => this.password
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("registerWithOAuth_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoResult = {
        xed.caas.domain.thrift.TUserInfoResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "registerWithOAuth"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val registerWithOAuth$args = RegisterWithOAuth.Args
  type registerWithOAuth$args = RegisterWithOAuth.Args

  val registerWithOAuth$result = RegisterWithOAuth.Result
  type registerWithOAuth$result = RegisterWithOAuth.Result

  object GetUserWithSessionId extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserWithSessionId_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String
      ): Args =
        new Args(
          sessionId
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.sessionId)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String
      ) = this(
        sessionId,
        Map.empty
      )
    
      def _1 = sessionId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserWithSessionId_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoResult = {
        xed.caas.domain.thrift.TUserInfoResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserWithSessionId"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserWithSessionId$args = GetUserWithSessionId.Args
  type getUserWithSessionId$args = GetUserWithSessionId.Args

  val getUserWithSessionId$result = GetUserWithSessionId.Result
  type getUserWithSessionId$result = GetUserWithSessionId.Result

  object GetUserWithUsername extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserWithUsername_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserWithUsername_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoResult = {
        xed.caas.domain.thrift.TUserInfoResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserWithUsername"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserWithUsername$args = GetUserWithUsername.Args
  type getUserWithUsername$args = GetUserWithUsername.Args

  val getUserWithUsername$result = GetUserWithUsername.Result
  type getUserWithUsername$result = GetUserWithUsername.Result

  object Logout extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("logout_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String
      ): Args =
        new Args(
          sessionId
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.sessionId)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String
      ) = this(
        sessionId,
        Map.empty
      )
    
      def _1 = sessionId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("logout_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TResult = {
        xed.caas.domain.thrift.TResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "logout"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val logout$args = Logout.Args
  type logout$args = Logout.Args

  val logout$result = Logout.Result
  type logout$result = Logout.Result

  object IsPermitted extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermitted_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
      val PermissionField = new TField("permission", TType.STRING, 2)
      val PermissionFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionField,
          false,
          true,
          PermissionFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
        if (_item.permission == null) throw new TProtocolException("Required field permission cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        if (item.permission == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permission)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            },
          permission =
            {
              val field = original.permission
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var permission: String = null
        var _got_permission = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    permission = readPermissionValue(_iprot)
                    _got_permission = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'permission' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        if (!_got_permission) throw new TProtocolException("Required field 'permission' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          permission,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String,
        permission: String
      ): Args =
        new Args(
          sessionId,
          permission
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
      @inline private[service] def readPermissionValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePermissionField(permission_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionField)
        writePermissionValue(permission_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionValue(permission_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(permission_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val permission: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String,
        permission: String
      ) = this(
        sessionId,
        permission,
        Map.empty
      )
    
      def _1 = sessionId
      def _2 = permission
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          sessionId,
          permission
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (permission ne null) writePermissionField(permission, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        permission: String = this.permission,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          permission,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case 1 => this.permission
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermitted_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermitted"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermitted$args = IsPermitted.Args
  type isPermitted$args = IsPermitted.Args

  val isPermitted$result = IsPermitted.Result
  type isPermitted$result = IsPermitted.Result

  object IsPermitteds extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermitteds_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
      val PermissionsField = new TField("permissions", TType.LIST, 2)
      val PermissionsFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionsField,
          false,
          true,
          PermissionsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
        if (_item.permissions == null) throw new TProtocolException("Required field permissions cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        if (item.permissions == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permissions)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            },
          permissions =
            {
              val field = original.permissions
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var permissions: Seq[String] = Seq[String]()
        var _got_permissions = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    permissions = readPermissionsValue(_iprot)
                    _got_permissions = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'permissions' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        if (!_got_permissions) throw new TProtocolException("Required field 'permissions' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          permissions,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String,
        permissions: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          sessionId,
          permissions
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
      @inline private[service] def readPermissionsValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writePermissionsField(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionsField)
        writePermissionsValue(permissions_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionsValue(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, permissions_item.size))
        permissions_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = permissions_item.size
            while (_i < _size) {
              val permissions_item_element = permissions_item(_i)
              _oprot.writeString(permissions_item_element)
              _i += 1
            }
          case _ =>
            permissions_item.foreach { permissions_item_element =>
              _oprot.writeString(permissions_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val permissions: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String,
        permissions: Seq[String] = Seq[String]()
      ) = this(
        sessionId,
        permissions,
        Map.empty
      )
    
      def _1 = sessionId
      def _2 = permissions
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          sessionId,
          permissions
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (permissions ne null) writePermissionsField(permissions, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        permissions: Seq[String] = this.permissions,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          permissions,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case 1 => this.permissions
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermitteds_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListBoolResult = {
        xed.caas.domain.thrift.TListBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermitteds"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermitteds$args = IsPermitteds.Args
  type isPermitteds$args = IsPermitteds.Args

  val isPermitteds$result = IsPermitteds.Result
  type isPermitteds$result = IsPermitteds.Result

  object IsPermittedAll extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedAll_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
      val PermissionsField = new TField("permissions", TType.LIST, 2)
      val PermissionsFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionsField,
          false,
          true,
          PermissionsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
        if (_item.permissions == null) throw new TProtocolException("Required field permissions cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        if (item.permissions == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permissions)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            },
          permissions =
            {
              val field = original.permissions
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var permissions: Seq[String] = Seq[String]()
        var _got_permissions = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    permissions = readPermissionsValue(_iprot)
                    _got_permissions = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'permissions' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        if (!_got_permissions) throw new TProtocolException("Required field 'permissions' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          permissions,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String,
        permissions: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          sessionId,
          permissions
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
      @inline private[service] def readPermissionsValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writePermissionsField(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionsField)
        writePermissionsValue(permissions_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionsValue(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, permissions_item.size))
        permissions_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = permissions_item.size
            while (_i < _size) {
              val permissions_item_element = permissions_item(_i)
              _oprot.writeString(permissions_item_element)
              _i += 1
            }
          case _ =>
            permissions_item.foreach { permissions_item_element =>
              _oprot.writeString(permissions_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val permissions: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String,
        permissions: Seq[String] = Seq[String]()
      ) = this(
        sessionId,
        permissions,
        Map.empty
      )
    
      def _1 = sessionId
      def _2 = permissions
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          sessionId,
          permissions
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (permissions ne null) writePermissionsField(permissions, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        permissions: Seq[String] = this.permissions,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          permissions,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case 1 => this.permissions
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedAll_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermittedAll"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermittedAll$args = IsPermittedAll.Args
  type isPermittedAll$args = IsPermittedAll.Args

  val isPermittedAll$result = IsPermittedAll.Result
  type isPermittedAll$result = IsPermittedAll.Result

  object IsPermittedUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PermissionField = new TField("permission", TType.STRING, 2)
      val PermissionFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionField,
          false,
          true,
          PermissionFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.permission == null) throw new TProtocolException("Required field permission cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.permission == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permission)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          permission =
            {
              val field = original.permission
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var permission: String = null
        var _got_permission = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    permission = readPermissionValue(_iprot)
                    _got_permission = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'permission' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_permission) throw new TProtocolException("Required field 'permission' was not found in serialized data for struct Args")
        new Args(
          username,
          permission,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        permission: String
      ): Args =
        new Args(
          username,
          permission
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPermissionValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writePermissionField(permission_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionField)
        writePermissionValue(permission_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionValue(permission_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(permission_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val permission: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        permission: String
      ) = this(
        username,
        permission,
        Map.empty
      )
    
      def _1 = username
      def _2 = permission
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          username,
          permission
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (permission ne null) writePermissionField(permission, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        permission: String = this.permission,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          permission,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.permission
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermittedUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermittedUser$args = IsPermittedUser.Args
  type isPermittedUser$args = IsPermittedUser.Args

  val isPermittedUser$result = IsPermittedUser.Result
  type isPermittedUser$result = IsPermittedUser.Result

  object IsPermittedsUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedsUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PermissionsField = new TField("permissions", TType.LIST, 2)
      val PermissionsFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionsField,
          false,
          true,
          PermissionsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.permissions == null) throw new TProtocolException("Required field permissions cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.permissions == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permissions)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          permissions =
            {
              val field = original.permissions
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var permissions: Seq[String] = Seq[String]()
        var _got_permissions = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    permissions = readPermissionsValue(_iprot)
                    _got_permissions = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'permissions' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_permissions) throw new TProtocolException("Required field 'permissions' was not found in serialized data for struct Args")
        new Args(
          username,
          permissions,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        permissions: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          username,
          permissions
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPermissionsValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writePermissionsField(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionsField)
        writePermissionsValue(permissions_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionsValue(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, permissions_item.size))
        permissions_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = permissions_item.size
            while (_i < _size) {
              val permissions_item_element = permissions_item(_i)
              _oprot.writeString(permissions_item_element)
              _i += 1
            }
          case _ =>
            permissions_item.foreach { permissions_item_element =>
              _oprot.writeString(permissions_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val permissions: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        permissions: Seq[String] = Seq[String]()
      ) = this(
        username,
        permissions,
        Map.empty
      )
    
      def _1 = username
      def _2 = permissions
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          username,
          permissions
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (permissions ne null) writePermissionsField(permissions, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        permissions: Seq[String] = this.permissions,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          permissions,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.permissions
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedsUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListBoolResult = {
        xed.caas.domain.thrift.TListBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermittedsUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermittedsUser$args = IsPermittedsUser.Args
  type isPermittedsUser$args = IsPermittedsUser.Args

  val isPermittedsUser$result = IsPermittedsUser.Result
  type isPermittedsUser$result = IsPermittedsUser.Result

  object IsPermittedUserAll extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedUserAll_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val PermissionsField = new TField("permissions", TType.LIST, 2)
      val PermissionsFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          PermissionsField,
          false,
          true,
          PermissionsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.permissions == null) throw new TProtocolException("Required field permissions cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.permissions == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.permissions)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          permissions =
            {
              val field = original.permissions
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var permissions: Seq[String] = Seq[String]()
        var _got_permissions = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    permissions = readPermissionsValue(_iprot)
                    _got_permissions = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'permissions' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_permissions) throw new TProtocolException("Required field 'permissions' was not found in serialized data for struct Args")
        new Args(
          username,
          permissions,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        permissions: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          username,
          permissions
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readPermissionsValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writePermissionsField(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PermissionsField)
        writePermissionsValue(permissions_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePermissionsValue(permissions_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, permissions_item.size))
        permissions_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = permissions_item.size
            while (_i < _size) {
              val permissions_item_element = permissions_item(_i)
              _oprot.writeString(permissions_item_element)
              _i += 1
            }
          case _ =>
            permissions_item.foreach { permissions_item_element =>
              _oprot.writeString(permissions_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val permissions: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        permissions: Seq[String] = Seq[String]()
      ) = this(
        username,
        permissions,
        Map.empty
      )
    
      def _1 = username
      def _2 = permissions
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          username,
          permissions
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (permissions ne null) writePermissionsField(permissions, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        permissions: Seq[String] = this.permissions,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          permissions,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.permissions
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("isPermittedUserAll_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "isPermittedUserAll"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val isPermittedUserAll$args = IsPermittedUserAll.Args
  type isPermittedUserAll$args = IsPermittedUserAll.Args

  val isPermittedUserAll$result = IsPermittedUserAll.Result
  type isPermittedUserAll$result = IsPermittedUserAll.Result

  object GetUserRoles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserRoles_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String
      ): Args =
        new Args(
          sessionId
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.sessionId)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String
      ) = this(
        sessionId,
        Map.empty
      )
    
      def _1 = sessionId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListStringResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getUserRoles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListStringResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListStringResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListStringResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListStringResult = {
        xed.caas.domain.thrift.TListStringResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListStringResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListStringResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListStringResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListStringResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListStringResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getUserRoles"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getUserRoles$args = GetUserRoles.Args
  type getUserRoles$args = GetUserRoles.Args

  val getUserRoles$result = GetUserRoles.Result
  type getUserRoles$result = GetUserRoles.Result

  object HasRole extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRole_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
      val RoleField = new TField("role", TType.STRING, 2)
      val RoleFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleField,
          false,
          true,
          RoleFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
        if (_item.role == null) throw new TProtocolException("Required field role cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        if (item.role == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.role)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            },
          role =
            {
              val field = original.role
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var role: String = null
        var _got_role = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    role = readRoleValue(_iprot)
                    _got_role = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'role' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        if (!_got_role) throw new TProtocolException("Required field 'role' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          role,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String,
        role: String
      ): Args =
        new Args(
          sessionId,
          role
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
      @inline private[service] def readRoleValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeRoleField(role_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleField)
        writeRoleValue(role_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleValue(role_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(role_item)
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val role: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String,
        role: String
      ) = this(
        sessionId,
        role,
        Map.empty
      )
    
      def _1 = sessionId
      def _2 = role
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          sessionId,
          role
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (role ne null) writeRoleField(role, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        role: String = this.role,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          role,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case 1 => this.role
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRole_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "hasRole"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val hasRole$args = HasRole.Args
  type hasRole$args = HasRole.Args

  val hasRole$result = HasRole.Result
  type hasRole$result = HasRole.Result

  object HasRoles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRoles_args")
      val SessionIdField = new TField("sessionId", TType.STRING, 1)
      val SessionIdFieldManifest = implicitly[Manifest[String]]
      val RolesField = new TField("roles", TType.LIST, 2)
      val RolesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SessionIdField,
          false,
          true,
          SessionIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RolesField,
          false,
          true,
          RolesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.sessionId == null) throw new TProtocolException("Required field sessionId cannot be null")
        if (_item.roles == null) throw new TProtocolException("Required field roles cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.sessionId == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.sessionId)
        if (item.roles == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roles)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          sessionId =
            {
              val field = original.sessionId
              field
            },
          roles =
            {
              val field = original.roles
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var sessionId: String = null
        var _got_sessionId = false
        var roles: Seq[String] = Seq[String]()
        var _got_roles = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    sessionId = readSessionIdValue(_iprot)
                    _got_sessionId = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'sessionId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    roles = readRolesValue(_iprot)
                    _got_roles = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'roles' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_sessionId) throw new TProtocolException("Required field 'sessionId' was not found in serialized data for struct Args")
        if (!_got_roles) throw new TProtocolException("Required field 'roles' was not found in serialized data for struct Args")
        new Args(
          sessionId,
          roles,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        sessionId: String,
        roles: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          sessionId,
          roles
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readSessionIdValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSessionIdField(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SessionIdField)
        writeSessionIdValue(sessionId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSessionIdValue(sessionId_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(sessionId_item)
      }
    
      @inline private[service] def readRolesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeRolesField(roles_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RolesField)
        writeRolesValue(roles_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRolesValue(roles_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, roles_item.size))
        roles_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = roles_item.size
            while (_i < _size) {
              val roles_item_element = roles_item(_i)
              _oprot.writeString(roles_item_element)
              _i += 1
            }
          case _ =>
            roles_item.foreach { roles_item_element =>
              _oprot.writeString(roles_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val sessionId: String,
        val roles: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        sessionId: String,
        roles: Seq[String] = Seq[String]()
      ) = this(
        sessionId,
        roles,
        Map.empty
      )
    
      def _1 = sessionId
      def _2 = roles
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          sessionId,
          roles
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (sessionId ne null) writeSessionIdField(sessionId, _oprot)
        if (roles ne null) writeRolesField(roles, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        sessionId: String = this.sessionId,
        roles: Seq[String] = this.roles,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          sessionId,
          roles,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.sessionId
        case 1 => this.roles
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRoles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListBoolResult = {
        xed.caas.domain.thrift.TListBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "hasRoles"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val hasRoles$args = HasRoles.Args
  type hasRoles$args = HasRoles.Args

  val hasRoles$result = HasRoles.Result
  type hasRoles$result = HasRoles.Result

  object HasRoleUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRoleUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleNameField = new TField("roleName", TType.STRING, 2)
      val RoleNameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleNameField,
          false,
          true,
          RoleNameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.roleName == null) throw new TProtocolException("Required field roleName cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.roleName == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roleName)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          roleName =
            {
              val field = original.roleName
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var roleName: String = null
        var _got_roleName = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    roleName = readRoleNameValue(_iprot)
                    _got_roleName = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'roleName' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_roleName) throw new TProtocolException("Required field 'roleName' was not found in serialized data for struct Args")
        new Args(
          username,
          roleName,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        roleName: String
      ): Args =
        new Args(
          username,
          roleName
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleNameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeRoleNameField(roleName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleNameField)
        writeRoleNameValue(roleName_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleNameValue(roleName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(roleName_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val roleName: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        roleName: String
      ) = this(
        username,
        roleName,
        Map.empty
      )
    
      def _1 = username
      def _2 = roleName
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          username,
          roleName
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (roleName ne null) writeRoleNameField(roleName, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        roleName: String = this.roleName,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          roleName,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.roleName
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasRoleUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "hasRoleUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val hasRoleUser$args = HasRoleUser.Args
  type hasRoleUser$args = HasRoleUser.Args

  val hasRoleUser$result = HasRoleUser.Result
  type hasRoleUser$result = HasRoleUser.Result

  object HasAllRoleUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasAllRoleUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleNamesField = new TField("roleNames", TType.LIST, 2)
      val RoleNamesFieldManifest = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleNamesField,
          false,
          true,
          RoleNamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.roleNames == null) throw new TProtocolException("Required field roleNames cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.roleNames == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roleNames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          roleNames =
            {
              val field = original.roleNames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var roleNames: Seq[String] = Seq[String]()
        var _got_roleNames = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    roleNames = readRoleNamesValue(_iprot)
                    _got_roleNames = true
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'roleNames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_roleNames) throw new TProtocolException("Required field 'roleNames' was not found in serialized data for struct Args")
        new Args(
          username,
          roleNames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        roleNames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          username,
          roleNames
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Seq[String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleNamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeRoleNamesField(roleNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleNamesField)
        writeRoleNamesValue(roleNames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleNamesValue(roleNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, roleNames_item.size))
        roleNames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = roleNames_item.size
            while (_i < _size) {
              val roleNames_item_element = roleNames_item(_i)
              _oprot.writeString(roleNames_item_element)
              _i += 1
            }
          case _ =>
            roleNames_item.foreach { roleNames_item_element =>
              _oprot.writeString(roleNames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val roleNames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        roleNames: Seq[String] = Seq[String]()
      ) = this(
        username,
        roleNames,
        Map.empty
      )
    
      def _1 = username
      def _2 = roleNames
    
      def toTuple: _root_.scala.Tuple2[String, Seq[String]] = {
        (
          username,
          roleNames
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (roleNames ne null) writeRoleNamesField(roleNames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        roleNames: Seq[String] = this.roleNames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          roleNames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.roleNames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("hasAllRoleUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "hasAllRoleUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val hasAllRoleUser$args = HasAllRoleUser.Args
  type hasAllRoleUser$args = HasAllRoleUser.Args

  val hasAllRoleUser$result = HasAllRoleUser.Result
  type hasAllRoleUser$result = HasAllRoleUser.Result

  object GetAllUsername extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllUsername_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListStringResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllUsername_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListStringResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListStringResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListStringResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListStringResult = {
        xed.caas.domain.thrift.TListStringResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListStringResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListStringResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListStringResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListStringResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListStringResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getAllUsername"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getAllUsername$args = GetAllUsername.Args
  type getAllUsername$args = GetAllUsername.Args

  val getAllUsername$result = GetAllUsername.Result
  type getAllUsername$result = GetAllUsername.Result

  object GetActiveUsername extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getActiveUsername_args")
      val FromField = new TField("from", TType.I32, 1)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val SizeField = new TField("size", TType.I32, 2)
      val SizeFieldManifest = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SizeField,
          false,
          true,
          SizeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.from)
        buf ++= validateField(item.size)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          from =
            {
              val field = original.from
              field
            },
          size =
            {
              val field = original.size
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var from: Int = 0
        var _got_from = false
        var size: Int = 0
        var _got_size = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    size = readSizeValue(_iprot)
                    _got_size = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'size' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_size) throw new TProtocolException("Required field 'size' was not found in serialized data for struct Args")
        new Args(
          from,
          size,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        from: Int,
        size: Int
      ): Args =
        new Args(
          from,
          size
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readSizeValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSizeField(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SizeField)
        writeSizeValue(size_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSizeValue(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(size_item)
      }
    
    
    }
    
    class Args(
        val from: Int,
        val size: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        from: Int,
        size: Int
      ) = this(
        from,
        size,
        Map.empty
      )
    
      def _1 = from
      def _2 = size
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          from,
          size
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeFromField(from, _oprot)
        writeSizeField(size, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        from: Int = this.from,
        size: Int = this.size,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          from,
          size,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.from
        case 1 => this.size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListUserResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getActiveUsername_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListUserResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListUserResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListUserResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListUserResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListUserResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListUserResult = {
        xed.caas.domain.thrift.TListUserResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListUserResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListUserResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListUserResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListUserResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListUserResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListUserResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListUserResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListUserResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListUserResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListUserResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getActiveUsername"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getActiveUsername$args = GetActiveUsername.Args
  type getActiveUsername$args = GetActiveUsername.Args

  val getActiveUsername$result = GetActiveUsername.Result
  type getActiveUsername$result = GetActiveUsername.Result

  object InsertUserRoles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertUserRoles_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleIdsField = new TField("roleIds", TType.SET, 2)
      val RoleIdsFieldManifest = implicitly[Manifest[Set[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleIdsField,
          false,
          true,
          RoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.roleIds == null) throw new TProtocolException("Required field roleIds cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.roleIds == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roleIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          roleIds =
            {
              val field = original.roleIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var roleIds: Set[Int] = Set[Int]()
        var _got_roleIds = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.SET =>
                    roleIds = readRoleIdsValue(_iprot)
                    _got_roleIds = true
                  case _actualType =>
                    val _expectedType = TType.SET
                    throw new TProtocolException(
                      "Received wrong type for field 'roleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_roleIds) throw new TProtocolException("Required field 'roleIds' was not found in serialized data for struct Args")
        new Args(
          username,
          roleIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        roleIds: Set[Int] = Set[Int]()
      ): Args =
        new Args(
          username,
          roleIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Set[Int]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleIdsValue(_iprot: TProtocol): Set[Int] = {
        val _set = _iprot.readSetBegin()
        if (_set.size == 0) {
          _iprot.readSetEnd()
          Set.empty[Int]
        } else {
          val _rv = new mutable$HashSet[Int]
          var _i = 0
          while (_i < _set.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readSetEnd()
          _rv
        }
      }
    
      @inline private def writeRoleIdsField(roleIds_item: Set[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleIdsField)
        writeRoleIdsValue(roleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleIdsValue(roleIds_item: Set[Int], _oprot: TProtocol): Unit = {
        _oprot.writeSetBegin(new TSet(TType.I32, roleIds_item.size))
        roleIds_item.foreach { roleIds_item_element =>
          _oprot.writeI32(roleIds_item_element)
        }
        _oprot.writeSetEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val roleIds: Set[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Set[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        roleIds: Set[Int] = Set[Int]()
      ) = this(
        username,
        roleIds,
        Map.empty
      )
    
      def _1 = username
      def _2 = roleIds
    
      def toTuple: _root_.scala.Tuple2[String, Set[Int]] = {
        (
          username,
          roleIds
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (roleIds ne null) writeRoleIdsField(roleIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        roleIds: Set[Int] = this.roleIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          roleIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.roleIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertUserRoles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "insertUserRoles"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val insertUserRoles$args = InsertUserRoles.Args
  type insertUserRoles$args = InsertUserRoles.Args

  val insertUserRoles$result = InsertUserRoles.Result
  type insertUserRoles$result = InsertUserRoles.Result

  object InsertExpirableUserRoles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertExpirableUserRoles_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleIdsField = new TField("roleIds", TType.MAP, 2)
      val RoleIdsFieldManifest = implicitly[Manifest[Map[Int, Long]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleIdsField,
          false,
          true,
          RoleIdsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          _root_.scala.Some(implicitly[Manifest[Long]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.roleIds == null) throw new TProtocolException("Required field roleIds cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.roleIds == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roleIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          roleIds =
            {
              val field = original.roleIds
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var roleIds: Map[Int, Long] = Map[Int, Long]()
        var _got_roleIds = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.MAP =>
                    roleIds = readRoleIdsValue(_iprot)
                    _got_roleIds = true
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'roleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_roleIds) throw new TProtocolException("Required field 'roleIds' was not found in serialized data for struct Args")
        new Args(
          username,
          roleIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        roleIds: Map[Int, Long] = Map[Int, Long]()
      ): Args =
        new Args(
          username,
          roleIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Map[Int, Long]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleIdsValue(_iprot: TProtocol): Map[Int, Long] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[Int, Long]
        } else {
          val _rv = new mutable$HashMap[Int, Long]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readI32()
            }
            val _value = {
              _iprot.readI64()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeRoleIdsField(roleIds_item: Map[Int, Long], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleIdsField)
        writeRoleIdsValue(roleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleIdsValue(roleIds_item: Map[Int, Long], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.I32, TType.I64, roleIds_item.size))
        roleIds_item.foreach { case (roleIds_item_key, roleIds_item_value) =>
          _oprot.writeI32(roleIds_item_key)
          _oprot.writeI64(roleIds_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val roleIds: Map[Int, Long],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Map[Int, Long]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        roleIds: Map[Int, Long] = Map[Int, Long]()
      ) = this(
        username,
        roleIds,
        Map.empty
      )
    
      def _1 = username
      def _2 = roleIds
    
      def toTuple: _root_.scala.Tuple2[String, Map[Int, Long]] = {
        (
          username,
          roleIds
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (roleIds ne null) writeRoleIdsField(roleIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        roleIds: Map[Int, Long] = this.roleIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          roleIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.roleIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertExpirableUserRoles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "insertExpirableUserRoles"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val insertExpirableUserRoles$args = InsertExpirableUserRoles.Args
  type insertExpirableUserRoles$args = InsertExpirableUserRoles.Args

  val insertExpirableUserRoles$result = InsertExpirableUserRoles.Result
  type insertExpirableUserRoles$result = InsertExpirableUserRoles.Result

  object InsertUserRole extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertUserRole_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleField = new TField("role", TType.I32, 2)
      val RoleFieldManifest = implicitly[Manifest[Int]]
      val ExpireTimeField = new TField("expireTime", TType.I64, 3)
      val ExpireTimeFieldManifest = implicitly[Manifest[Long]]
      val ForceField = new TField("force", TType.BOOL, 4)
      val ForceFieldManifest = implicitly[Manifest[Boolean]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleField,
          false,
          true,
          RoleFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ExpireTimeField,
          false,
          true,
          ExpireTimeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ForceField,
          false,
          true,
          ForceFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf ++= validateField(item.role)
        buf ++= validateField(item.expireTime)
        buf ++= validateField(item.force)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          role =
            {
              val field = original.role
              field
            },
          expireTime =
            {
              val field = original.expireTime
              field
            },
          force =
            {
              val field = original.force
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var role: Int = 0
        var _got_role = false
        var expireTime: Long = 0L
        var _got_expireTime = false
        var force: Boolean = false
        var _got_force = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    role = readRoleValue(_iprot)
                    _got_role = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'role' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I64 =>
                    expireTime = readExpireTimeValue(_iprot)
                    _got_expireTime = true
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'expireTime' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.BOOL =>
                    force = readForceValue(_iprot)
                    _got_force = true
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'force' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_role) throw new TProtocolException("Required field 'role' was not found in serialized data for struct Args")
        if (!_got_expireTime) throw new TProtocolException("Required field 'expireTime' was not found in serialized data for struct Args")
        if (!_got_force) throw new TProtocolException("Required field 'force' was not found in serialized data for struct Args")
        new Args(
          username,
          role,
          expireTime,
          force,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        role: Int,
        expireTime: Long,
        force: Boolean
      ): Args =
        new Args(
          username,
          role,
          expireTime,
          force
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[String, Int, Long, Boolean]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeRoleField(role_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleField)
        writeRoleValue(role_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleValue(role_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(role_item)
      }
    
      @inline private[service] def readExpireTimeValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeExpireTimeField(expireTime_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExpireTimeField)
        writeExpireTimeValue(expireTime_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExpireTimeValue(expireTime_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(expireTime_item)
      }
    
      @inline private[service] def readForceValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeForceField(force_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ForceField)
        writeForceValue(force_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeForceValue(force_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(force_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val role: Int,
        val expireTime: Long,
        val force: Boolean,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[String, Int, Long, Boolean]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        role: Int,
        expireTime: Long,
        force: Boolean
      ) = this(
        username,
        role,
        expireTime,
        force,
        Map.empty
      )
    
      def _1 = username
      def _2 = role
      def _3 = expireTime
      def _4 = force
    
      def toTuple: _root_.scala.Tuple4[String, Int, Long, Boolean] = {
        (
          username,
          role,
          expireTime,
          force
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        writeRoleField(role, _oprot)
        writeExpireTimeField(expireTime, _oprot)
        writeForceField(force, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        role: Int = this.role,
        expireTime: Long = this.expireTime,
        force: Boolean = this.force,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          role,
          expireTime,
          force,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.role
        case 2 => this.expireTime
        case 3 => this.force
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("insertUserRole_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "insertUserRole"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val insertUserRole$args = InsertUserRole.Args
  type insertUserRole$args = InsertUserRole.Args

  val insertUserRole$result = InsertUserRole.Result
  type insertUserRole$result = InsertUserRole.Result

  object DeleteUserRoles extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteUserRoles_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val RoleIdsField = new TField("roleIds", TType.SET, 2)
      val RoleIdsFieldManifest = implicitly[Manifest[Set[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RoleIdsField,
          false,
          true,
          RoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.roleIds == null) throw new TProtocolException("Required field roleIds cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.roleIds == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.roleIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          roleIds =
            {
              val field = original.roleIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var roleIds: Set[Int] = Set[Int]()
        var _got_roleIds = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.SET =>
                    roleIds = readRoleIdsValue(_iprot)
                    _got_roleIds = true
                  case _actualType =>
                    val _expectedType = TType.SET
                    throw new TProtocolException(
                      "Received wrong type for field 'roleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_roleIds) throw new TProtocolException("Required field 'roleIds' was not found in serialized data for struct Args")
        new Args(
          username,
          roleIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        roleIds: Set[Int] = Set[Int]()
      ): Args =
        new Args(
          username,
          roleIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, Set[Int]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readRoleIdsValue(_iprot: TProtocol): Set[Int] = {
        val _set = _iprot.readSetBegin()
        if (_set.size == 0) {
          _iprot.readSetEnd()
          Set.empty[Int]
        } else {
          val _rv = new mutable$HashSet[Int]
          var _i = 0
          while (_i < _set.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readSetEnd()
          _rv
        }
      }
    
      @inline private def writeRoleIdsField(roleIds_item: Set[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RoleIdsField)
        writeRoleIdsValue(roleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRoleIdsValue(roleIds_item: Set[Int], _oprot: TProtocol): Unit = {
        _oprot.writeSetBegin(new TSet(TType.I32, roleIds_item.size))
        roleIds_item.foreach { roleIds_item_element =>
          _oprot.writeI32(roleIds_item_element)
        }
        _oprot.writeSetEnd()
      }
    
    
    }
    
    class Args(
        val username: String,
        val roleIds: Set[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, Set[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        roleIds: Set[Int] = Set[Int]()
      ) = this(
        username,
        roleIds,
        Map.empty
      )
    
      def _1 = username
      def _2 = roleIds
    
      def toTuple: _root_.scala.Tuple2[String, Set[Int]] = {
        (
          username,
          roleIds
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (roleIds ne null) writeRoleIdsField(roleIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        roleIds: Set[Int] = this.roleIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          roleIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.roleIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteUserRoles_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "deleteUserRoles"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val deleteUserRoles$args = DeleteUserRoles.Args
  type deleteUserRoles$args = DeleteUserRoles.Args

  val deleteUserRoles$result = DeleteUserRoles.Result
  type deleteUserRoles$result = DeleteUserRoles.Result

  object GetListUserRole extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getListUserRole_args")
      val NotInRoleIdsField = new TField("notInRoleIds", TType.LIST, 1)
      val NotInRoleIdsFieldManifest = implicitly[Manifest[Seq[Int]]]
      val InRoleIdsField = new TField("inRoleIds", TType.LIST, 2)
      val InRoleIdsFieldManifest = implicitly[Manifest[Seq[Int]]]
      val FromField = new TField("from", TType.I32, 3)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val SizeField = new TField("size", TType.I32, 4)
      val SizeFieldManifest = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          NotInRoleIdsField,
          true,
          false,
          NotInRoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          InRoleIdsField,
          true,
          false,
          InRoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SizeField,
          false,
          true,
          SizeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.notInRoleIds)
        buf ++= validateField(item.inRoleIds)
        buf ++= validateField(item.from)
        buf ++= validateField(item.size)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          notInRoleIds =
            {
              val field = original.notInRoleIds
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          inRoleIds =
            {
              val field = original.inRoleIds
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          from =
            {
              val field = original.from
              field
            },
          size =
            {
              val field = original.size
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var from: Int = 0
        var _got_from = false
        var size: Int = 0
        var _got_size = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    notInRoleIds = _root_.scala.Some(readNotInRoleIdsValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'notInRoleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    inRoleIds = _root_.scala.Some(readInRoleIdsValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'inRoleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.I32 =>
                    size = readSizeValue(_iprot)
                    _got_size = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'size' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_size) throw new TProtocolException("Required field 'size' was not found in serialized data for struct Args")
        new Args(
          notInRoleIds,
          inRoleIds,
          from,
          size,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        from: Int,
        size: Int
      ): Args =
        new Args(
          notInRoleIds,
          inRoleIds,
          from,
          size
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[Int]], Option[Seq[Int]], Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readNotInRoleIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeNotInRoleIdsField(notInRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NotInRoleIdsField)
        writeNotInRoleIdsValue(notInRoleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNotInRoleIdsValue(notInRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, notInRoleIds_item.size))
        notInRoleIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = notInRoleIds_item.size
            while (_i < _size) {
              val notInRoleIds_item_element = notInRoleIds_item(_i)
              _oprot.writeI32(notInRoleIds_item_element)
              _i += 1
            }
          case _ =>
            notInRoleIds_item.foreach { notInRoleIds_item_element =>
              _oprot.writeI32(notInRoleIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[service] def readInRoleIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeInRoleIdsField(inRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(InRoleIdsField)
        writeInRoleIdsValue(inRoleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeInRoleIdsValue(inRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, inRoleIds_item.size))
        inRoleIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = inRoleIds_item.size
            while (_i < _size) {
              val inRoleIds_item_element = inRoleIds_item(_i)
              _oprot.writeI32(inRoleIds_item_element)
              _i += 1
            }
          case _ =>
            inRoleIds_item.foreach { inRoleIds_item_element =>
              _oprot.writeI32(inRoleIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readSizeValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSizeField(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SizeField)
        writeSizeValue(size_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSizeValue(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(size_item)
      }
    
    
    }
    
    class Args(
        val notInRoleIds: _root_.scala.Option[Seq[Int]],
        val inRoleIds: _root_.scala.Option[Seq[Int]],
        val from: Int,
        val size: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[Option[Seq[Int]], Option[Seq[Int]], Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        from: Int,
        size: Int
      ) = this(
        notInRoleIds,
        inRoleIds,
        from,
        size,
        Map.empty
      )
    
      def _1 = notInRoleIds
      def _2 = inRoleIds
      def _3 = from
      def _4 = size
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[Int]], Option[Seq[Int]], Int, Int] = {
        (
          notInRoleIds,
          inRoleIds,
          from,
          size
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (notInRoleIds.isDefined) writeNotInRoleIdsField(notInRoleIds.get, _oprot)
        if (inRoleIds.isDefined) writeInRoleIdsField(inRoleIds.get, _oprot)
        writeFromField(from, _oprot)
        writeSizeField(size, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        notInRoleIds: _root_.scala.Option[Seq[Int]] = this.notInRoleIds,
        inRoleIds: _root_.scala.Option[Seq[Int]] = this.inRoleIds,
        from: Int = this.from,
        size: Int = this.size,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          notInRoleIds,
          inRoleIds,
          from,
          size,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.notInRoleIds
        case 1 => this.inRoleIds
        case 2 => this.from
        case 3 => this.size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoPageable
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getListUserRole_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoPageable]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoPageable.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoPageable = {
        xed.caas.domain.thrift.TUserInfoPageable.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoPageable, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoPageable, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoPageable] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoPageable]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoPageable] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoPageable]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoPageable]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getListUserRole"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getListUserRole$args = GetListUserRole.Args
  type getListUserRole$args = GetListUserRole.Args

  val getListUserRole$result = GetListUserRole.Result
  type getListUserRole$result = GetListUserRole.Result

  object SearchListUserRole extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("searchListUserRole_args")
      val UsernameSearchKeyField = new TField("usernameSearchKey", TType.STRING, 1)
      val UsernameSearchKeyFieldManifest = implicitly[Manifest[String]]
      val NotInRoleIdsField = new TField("notInRoleIds", TType.LIST, 2)
      val NotInRoleIdsFieldManifest = implicitly[Manifest[Seq[Int]]]
      val InRoleIdsField = new TField("inRoleIds", TType.LIST, 3)
      val InRoleIdsFieldManifest = implicitly[Manifest[Seq[Int]]]
      val FromField = new TField("from", TType.I32, 4)
      val FromFieldManifest = implicitly[Manifest[Int]]
      val SizeField = new TField("size", TType.I32, 5)
      val SizeFieldManifest = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameSearchKeyField,
          false,
          true,
          UsernameSearchKeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          NotInRoleIdsField,
          true,
          false,
          NotInRoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          InRoleIdsField,
          true,
          false,
          InRoleIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FromField,
          false,
          true,
          FromFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SizeField,
          false,
          true,
          SizeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.usernameSearchKey == null) throw new TProtocolException("Required field usernameSearchKey cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.usernameSearchKey == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.usernameSearchKey)
        buf ++= validateField(item.notInRoleIds)
        buf ++= validateField(item.inRoleIds)
        buf ++= validateField(item.from)
        buf ++= validateField(item.size)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          usernameSearchKey =
            {
              val field = original.usernameSearchKey
              field
            },
          notInRoleIds =
            {
              val field = original.notInRoleIds
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          inRoleIds =
            {
              val field = original.inRoleIds
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          from =
            {
              val field = original.from
              field
            },
          size =
            {
              val field = original.size
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var usernameSearchKey: String = null
        var _got_usernameSearchKey = false
        var notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var from: Int = 0
        var _got_from = false
        var size: Int = 0
        var _got_size = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    usernameSearchKey = readUsernameSearchKeyValue(_iprot)
                    _got_usernameSearchKey = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'usernameSearchKey' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    notInRoleIds = _root_.scala.Some(readNotInRoleIdsValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'notInRoleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.LIST =>
                    inRoleIds = _root_.scala.Some(readInRoleIdsValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'inRoleIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.I32 =>
                    from = readFromValue(_iprot)
                    _got_from = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'from' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 5 =>
                _field.`type` match {
                  case TType.I32 =>
                    size = readSizeValue(_iprot)
                    _got_size = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'size' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_usernameSearchKey) throw new TProtocolException("Required field 'usernameSearchKey' was not found in serialized data for struct Args")
        if (!_got_from) throw new TProtocolException("Required field 'from' was not found in serialized data for struct Args")
        if (!_got_size) throw new TProtocolException("Required field 'size' was not found in serialized data for struct Args")
        new Args(
          usernameSearchKey,
          notInRoleIds,
          inRoleIds,
          from,
          size,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        usernameSearchKey: String,
        notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        from: Int,
        size: Int
      ): Args =
        new Args(
          usernameSearchKey,
          notInRoleIds,
          inRoleIds,
          from,
          size
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple5[String, Option[Seq[Int]], Option[Seq[Int]], Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameSearchKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameSearchKeyField(usernameSearchKey_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameSearchKeyField)
        writeUsernameSearchKeyValue(usernameSearchKey_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameSearchKeyValue(usernameSearchKey_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(usernameSearchKey_item)
      }
    
      @inline private[service] def readNotInRoleIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeNotInRoleIdsField(notInRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NotInRoleIdsField)
        writeNotInRoleIdsValue(notInRoleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNotInRoleIdsValue(notInRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, notInRoleIds_item.size))
        notInRoleIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = notInRoleIds_item.size
            while (_i < _size) {
              val notInRoleIds_item_element = notInRoleIds_item(_i)
              _oprot.writeI32(notInRoleIds_item_element)
              _i += 1
            }
          case _ =>
            notInRoleIds_item.foreach { notInRoleIds_item_element =>
              _oprot.writeI32(notInRoleIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[service] def readInRoleIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeInRoleIdsField(inRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(InRoleIdsField)
        writeInRoleIdsValue(inRoleIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeInRoleIdsValue(inRoleIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, inRoleIds_item.size))
        inRoleIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = inRoleIds_item.size
            while (_i < _size) {
              val inRoleIds_item_element = inRoleIds_item(_i)
              _oprot.writeI32(inRoleIds_item_element)
              _i += 1
            }
          case _ =>
            inRoleIds_item.foreach { inRoleIds_item_element =>
              _oprot.writeI32(inRoleIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[service] def readFromValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeFromField(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FromField)
        writeFromValue(from_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFromValue(from_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(from_item)
      }
    
      @inline private[service] def readSizeValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSizeField(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SizeField)
        writeSizeValue(size_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSizeValue(size_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(size_item)
      }
    
    
    }
    
    class Args(
        val usernameSearchKey: String,
        val notInRoleIds: _root_.scala.Option[Seq[Int]],
        val inRoleIds: _root_.scala.Option[Seq[Int]],
        val from: Int,
        val size: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product5[String, Option[Seq[Int]], Option[Seq[Int]], Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        usernameSearchKey: String,
        notInRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        inRoleIds: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        from: Int,
        size: Int
      ) = this(
        usernameSearchKey,
        notInRoleIds,
        inRoleIds,
        from,
        size,
        Map.empty
      )
    
      def _1 = usernameSearchKey
      def _2 = notInRoleIds
      def _3 = inRoleIds
      def _4 = from
      def _5 = size
    
      def toTuple: _root_.scala.Tuple5[String, Option[Seq[Int]], Option[Seq[Int]], Int, Int] = {
        (
          usernameSearchKey,
          notInRoleIds,
          inRoleIds,
          from,
          size
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (usernameSearchKey ne null) writeUsernameSearchKeyField(usernameSearchKey, _oprot)
        if (notInRoleIds.isDefined) writeNotInRoleIdsField(notInRoleIds.get, _oprot)
        if (inRoleIds.isDefined) writeInRoleIdsField(inRoleIds.get, _oprot)
        writeFromField(from, _oprot)
        writeSizeField(size, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        usernameSearchKey: String = this.usernameSearchKey,
        notInRoleIds: _root_.scala.Option[Seq[Int]] = this.notInRoleIds,
        inRoleIds: _root_.scala.Option[Seq[Int]] = this.inRoleIds,
        from: Int = this.from,
        size: Int = this.size,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          usernameSearchKey,
          notInRoleIds,
          inRoleIds,
          from,
          size,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.usernameSearchKey
        case 1 => this.notInRoleIds
        case 2 => this.inRoleIds
        case 3 => this.from
        case 4 => this.size
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TUserInfoPageable
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("searchListUserRole_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TUserInfoPageable]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TUserInfoPageable.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TUserInfoPageable = {
        xed.caas.domain.thrift.TUserInfoPageable.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TUserInfoPageable, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TUserInfoPageable, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TUserInfoPageable] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TUserInfoPageable]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TUserInfoPageable] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TUserInfoPageable] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TUserInfoPageable]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TUserInfoPageable]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "searchListUserRole"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val searchListUserRole$args = SearchListUserRole.Args
  type searchListUserRole$args = SearchListUserRole.Args

  val searchListUserRole$result = SearchListUserRole.Result
  type searchListUserRole$result = SearchListUserRole.Result

  object ResetPasswordUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("resetPasswordUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val NewPasswordField = new TField("newPassword", TType.STRING, 2)
      val NewPasswordFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          NewPasswordField,
          false,
          true,
          NewPasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.newPassword == null) throw new TProtocolException("Required field newPassword cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.newPassword == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.newPassword)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          newPassword =
            {
              val field = original.newPassword
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var newPassword: String = null
        var _got_newPassword = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    newPassword = readNewPasswordValue(_iprot)
                    _got_newPassword = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'newPassword' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_newPassword) throw new TProtocolException("Required field 'newPassword' was not found in serialized data for struct Args")
        new Args(
          username,
          newPassword,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        newPassword: String
      ): Args =
        new Args(
          username,
          newPassword
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readNewPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeNewPasswordField(newPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NewPasswordField)
        writeNewPasswordValue(newPassword_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNewPasswordValue(newPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(newPassword_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val newPassword: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        newPassword: String
      ) = this(
        username,
        newPassword,
        Map.empty
      )
    
      def _1 = username
      def _2 = newPassword
    
      def toTuple: _root_.scala.Tuple2[String, String] = {
        (
          username,
          newPassword
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (newPassword ne null) writeNewPasswordField(newPassword, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        newPassword: String = this.newPassword,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          newPassword,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.newPassword
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("resetPasswordUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "resetPasswordUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val resetPasswordUser$args = ResetPasswordUser.Args
  type resetPasswordUser$args = ResetPasswordUser.Args

  val resetPasswordUser$result = ResetPasswordUser.Result
  type resetPasswordUser$result = ResetPasswordUser.Result

  object UpdatePasswordUser extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("updatePasswordUser_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
      val OldPasswordField = new TField("oldPassword", TType.STRING, 2)
      val OldPasswordFieldManifest = implicitly[Manifest[String]]
      val NewPasswordField = new TField("newPassword", TType.STRING, 3)
      val NewPasswordFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          OldPasswordField,
          false,
          true,
          OldPasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          NewPasswordField,
          false,
          true,
          NewPasswordFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
        if (_item.oldPassword == null) throw new TProtocolException("Required field oldPassword cannot be null")
        if (_item.newPassword == null) throw new TProtocolException("Required field newPassword cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        if (item.oldPassword == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(1))
        buf ++= validateField(item.oldPassword)
        if (item.newPassword == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(2))
        buf ++= validateField(item.newPassword)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            },
          oldPassword =
            {
              val field = original.oldPassword
              field
            },
          newPassword =
            {
              val field = original.newPassword
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var oldPassword: String = null
        var _got_oldPassword = false
        var newPassword: String = null
        var _got_newPassword = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    oldPassword = readOldPasswordValue(_iprot)
                    _got_oldPassword = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'oldPassword' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    newPassword = readNewPasswordValue(_iprot)
                    _got_newPassword = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'newPassword' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        if (!_got_oldPassword) throw new TProtocolException("Required field 'oldPassword' was not found in serialized data for struct Args")
        if (!_got_newPassword) throw new TProtocolException("Required field 'newPassword' was not found in serialized data for struct Args")
        new Args(
          username,
          oldPassword,
          newPassword,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String,
        oldPassword: String,
        newPassword: String
      ): Args =
        new Args(
          username,
          oldPassword,
          newPassword
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[String, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
      @inline private[service] def readOldPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeOldPasswordField(oldPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(OldPasswordField)
        writeOldPasswordValue(oldPassword_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeOldPasswordValue(oldPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(oldPassword_item)
      }
    
      @inline private[service] def readNewPasswordValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeNewPasswordField(newPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NewPasswordField)
        writeNewPasswordValue(newPassword_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNewPasswordValue(newPassword_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(newPassword_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val oldPassword: String,
        val newPassword: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[String, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String,
        oldPassword: String,
        newPassword: String
      ) = this(
        username,
        oldPassword,
        newPassword,
        Map.empty
      )
    
      def _1 = username
      def _2 = oldPassword
      def _3 = newPassword
    
      def toTuple: _root_.scala.Tuple3[String, String, String] = {
        (
          username,
          oldPassword,
          newPassword
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (oldPassword ne null) writeOldPasswordField(oldPassword, _oprot)
        if (newPassword ne null) writeNewPasswordField(newPassword, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        oldPassword: String = this.oldPassword,
        newPassword: String = this.newPassword,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          oldPassword,
          newPassword,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case 1 => this.oldPassword
        case 2 => this.newPassword
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("updatePasswordUser_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "updatePasswordUser"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val updatePasswordUser$args = UpdatePasswordUser.Args
  type updatePasswordUser$args = UpdatePasswordUser.Args

  val updatePasswordUser$result = UpdatePasswordUser.Result
  type updatePasswordUser$result = UpdatePasswordUser.Result

  object DeleteAllExpiredUserRole extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteAllExpiredUserRole_args")
      val DefaultRoleIdField = new TField("defaultRoleId", TType.I32, 1)
      val DefaultRoleIdFieldManifest = implicitly[Manifest[Int]]
      val MaxTimeField = new TField("maxTime", TType.I64, 2)
      val MaxTimeFieldManifest = implicitly[Manifest[Long]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DefaultRoleIdField,
          false,
          true,
          DefaultRoleIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          MaxTimeField,
          false,
          true,
          MaxTimeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.defaultRoleId)
        buf ++= validateField(item.maxTime)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          defaultRoleId =
            {
              val field = original.defaultRoleId
              field
            },
          maxTime =
            {
              val field = original.maxTime
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var defaultRoleId: Int = 0
        var _got_defaultRoleId = false
        var maxTime: Long = 0L
        var _got_maxTime = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    defaultRoleId = readDefaultRoleIdValue(_iprot)
                    _got_defaultRoleId = true
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'defaultRoleId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I64 =>
                    maxTime = readMaxTimeValue(_iprot)
                    _got_maxTime = true
                  case _actualType =>
                    val _expectedType = TType.I64
                    throw new TProtocolException(
                      "Received wrong type for field 'maxTime' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_defaultRoleId) throw new TProtocolException("Required field 'defaultRoleId' was not found in serialized data for struct Args")
        if (!_got_maxTime) throw new TProtocolException("Required field 'maxTime' was not found in serialized data for struct Args")
        new Args(
          defaultRoleId,
          maxTime,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        defaultRoleId: Int,
        maxTime: Long
      ): Args =
        new Args(
          defaultRoleId,
          maxTime
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Long]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[service] def readDefaultRoleIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDefaultRoleIdField(defaultRoleId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DefaultRoleIdField)
        writeDefaultRoleIdValue(defaultRoleId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDefaultRoleIdValue(defaultRoleId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(defaultRoleId_item)
      }
    
      @inline private[service] def readMaxTimeValue(_iprot: TProtocol): Long = {
        _iprot.readI64()
      }
    
      @inline private def writeMaxTimeField(maxTime_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MaxTimeField)
        writeMaxTimeValue(maxTime_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMaxTimeValue(maxTime_item: Long, _oprot: TProtocol): Unit = {
        _oprot.writeI64(maxTime_item)
      }
    
    
    }
    
    class Args(
        val defaultRoleId: Int,
        val maxTime: Long,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Long]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        defaultRoleId: Int,
        maxTime: Long
      ) = this(
        defaultRoleId,
        maxTime,
        Map.empty
      )
    
      def _1 = defaultRoleId
      def _2 = maxTime
    
      def toTuple: _root_.scala.Tuple2[Int, Long] = {
        (
          defaultRoleId,
          maxTime
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDefaultRoleIdField(defaultRoleId, _oprot)
        writeMaxTimeField(maxTime, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        defaultRoleId: Int = this.defaultRoleId,
        maxTime: Long = this.maxTime,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          defaultRoleId,
          maxTime,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.defaultRoleId
        case 1 => this.maxTime
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TBoolResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("deleteAllExpiredUserRole_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TBoolResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TBoolResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TBoolResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TBoolResult = {
        xed.caas.domain.thrift.TBoolResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TBoolResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TBoolResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TBoolResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TBoolResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TBoolResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TBoolResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TBoolResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "deleteAllExpiredUserRole"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val deleteAllExpiredUserRole$args = DeleteAllExpiredUserRole.Args
  type deleteAllExpiredUserRole$args = DeleteAllExpiredUserRole.Args

  val deleteAllExpiredUserRole$result = DeleteAllExpiredUserRole.Result
  type deleteAllExpiredUserRole$result = DeleteAllExpiredUserRole.Result

  object GetAllRoleInfo extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllRoleInfo_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListRoleInfoResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllRoleInfo_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListRoleInfoResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListRoleInfoResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListRoleInfoResult = {
        xed.caas.domain.thrift.TListRoleInfoResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListRoleInfoResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListRoleInfoResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListRoleInfoResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListRoleInfoResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListRoleInfoResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListRoleInfoResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListRoleInfoResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListRoleInfoResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getAllRoleInfo"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getAllRoleInfo$args = GetAllRoleInfo.Args
  type getAllRoleInfo$args = GetAllRoleInfo.Args

  val getAllRoleInfo$result = GetAllRoleInfo.Result
  type getAllRoleInfo$result = GetAllRoleInfo.Result

  object GetAllPermission extends com.twitter.scrooge.ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllPermission_args")
      val UsernameField = new TField("username", TType.STRING, 1)
      val UsernameFieldManifest = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          UsernameField,
          false,
          true,
          UsernameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
        if (_item.username == null) throw new TProtocolException("Required field username cannot be null")
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        if (item.username == null)
          buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(0))
        buf ++= validateField(item.username)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          username =
            {
              val field = original.username
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var username: String = null
        var _got_username = false
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRING =>
                    username = readUsernameValue(_iprot)
                    _got_username = true
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'username' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        if (!_got_username) throw new TProtocolException("Required field 'username' was not found in serialized data for struct Args")
        new Args(
          username,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        username: String
      ): Args =
        new Args(
          username
        )
    
      def unapply(_item: Args): _root_.scala.Option[String] = _root_.scala.Some(_item.username)
    
    
      @inline private[service] def readUsernameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeUsernameField(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(UsernameField)
        writeUsernameValue(username_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeUsernameValue(username_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(username_item)
      }
    
    
    }
    
    class Args(
        val username: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
      def this(
        username: String
      ) = this(
        username,
        Map.empty
      )
    
      def _1 = username
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (username ne null) writeUsernameField(username, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        username: String = this.username,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          username,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args]) &&
          _passthroughFields == other.asInstanceOf[Args]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.username
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = xed.caas.domain.thrift.TListStringResult
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct = new TStruct("getAllPermission_result")
      val SuccessField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest = implicitly[Manifest[xed.caas.domain.thrift.TListStringResult]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                xed.caas.domain.thrift.TListStringResult.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[xed.caas.domain.thrift.TListStringResult]] = _root_.scala.Some(_item.success)
    
    
      @inline private[service] def readSuccessValue(_iprot: TProtocol): xed.caas.domain.thrift.TListStringResult = {
        xed.caas.domain.thrift.TListStringResult.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: xed.caas.domain.thrift.TListStringResult, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[xed.caas.domain.thrift.TListStringResult] with ThriftStruct
      with _root_.scala.Product1[Option[xed.caas.domain.thrift.TListStringResult]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
      def this(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1 = success
    
      def successField: Option[xed.caas.domain.thrift.TListStringResult] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[xed.caas.domain.thrift.TListStringResult] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator)
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result]) &&
          _passthroughFields == other.asInstanceOf[Result]._passthroughFields
    
      override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[xed.caas.domain.thrift.TListStringResult]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[xed.caas.domain.thrift.TListStringResult]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getAllPermission"
    val serviceName: String = "TCaasService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getAllPermission$args = GetAllPermission.Args
  type getAllPermission$args = GetAllPermission.Args

  val getAllPermission$result = GetAllPermission.Result
  type getAllPermission$result = GetAllPermission.Result


  trait MethodPerEndpoint
    extends TCaasService[Future] {
    
    def ping(): Future[String]
    
    def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def login(username: String, password: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def loginOAuth(username: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def register(username: String, password: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def isCredentialDefault(oauthType: String, username: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteUser(username: String): Future[xed.caas.domain.thrift.TResult]
    
    def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def getUserWithSessionId(sessionId: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def getUserWithUsername(username: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def logout(sessionId: String): Future[xed.caas.domain.thrift.TResult]
    
    def isPermitted(sessionId: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermittedUser(username: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getUserRoles(sessionId: String): Future[xed.caas.domain.thrift.TListStringResult]
    
    def hasRole(sessionId: String, role: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def hasRoleUser(username: String, roleName: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getAllUsername(): Future[xed.caas.domain.thrift.TListStringResult]
    
    def getActiveUsername(from: Int, size: Int): Future[xed.caas.domain.thrift.TListUserResult]
    
    def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable]
    
    def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable]
    
    def resetPasswordUser(username: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def updatePasswordUser(username: String, oldPassword: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getAllRoleInfo(username: String): Future[xed.caas.domain.thrift.TListRoleInfoResult]
    
    def getAllPermission(username: String): Future[xed.caas.domain.thrift.TListStringResult]
  }

  object MethodPerEndpoint {

    def apply(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint = {
      new MethodPerEndpointImpl(servicePerEndpoint) {}
    }

    /**
     * Use `MethodPerEndpoint.apply()` instead of this constructor.
     */
    class MethodPerEndpointImpl protected (servicePerEndpoint: ServicePerEndpoint)
      extends MethodPerEndpoint {
        def ping(): Future[String] =
          servicePerEndpoint.ping(self.Ping.Args())
        def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
          servicePerEndpoint.renewSession(self.RenewSession.Args(oldSessionId, sessionTimeout))
        def login(username: String, password: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
          servicePerEndpoint.login(self.Login.Args(username, password, sessionTimeout))
        def loginOAuth(username: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
          servicePerEndpoint.loginOAuth(self.LoginOAuth.Args(username, sessionTimeout))
        def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
          servicePerEndpoint.loginWithOAuth(self.LoginWithOAuth.Args(oauthType, id, token, sessionTimeout, password))
        def register(username: String, password: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
          servicePerEndpoint.register(self.Register.Args(username, password))
        def isCredentialDefault(oauthType: String, username: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.isCredentialDefault(self.IsCredentialDefault.Args(oauthType, username))
        def deleteUser(username: String): Future[xed.caas.domain.thrift.TResult] =
          servicePerEndpoint.deleteUser(self.DeleteUser.Args(username))
        def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserInfoResult] =
          servicePerEndpoint.registerWithOAuth(self.RegisterWithOAuth.Args(oauthType, id, token, password))
        def getUserWithSessionId(sessionId: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
          servicePerEndpoint.getUserWithSessionId(self.GetUserWithSessionId.Args(sessionId))
        def getUserWithUsername(username: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
          servicePerEndpoint.getUserWithUsername(self.GetUserWithUsername.Args(username))
        def logout(sessionId: String): Future[xed.caas.domain.thrift.TResult] =
          servicePerEndpoint.logout(self.Logout.Args(sessionId))
        def isPermitted(sessionId: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.isPermitted(self.IsPermitted.Args(sessionId, permission))
        def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
          servicePerEndpoint.isPermitteds(self.IsPermitteds.Args(sessionId, permissions))
        def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.isPermittedAll(self.IsPermittedAll.Args(sessionId, permissions))
        def isPermittedUser(username: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.isPermittedUser(self.IsPermittedUser.Args(username, permission))
        def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
          servicePerEndpoint.isPermittedsUser(self.IsPermittedsUser.Args(username, permissions))
        def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.isPermittedUserAll(self.IsPermittedUserAll.Args(username, permissions))
        def getUserRoles(sessionId: String): Future[xed.caas.domain.thrift.TListStringResult] =
          servicePerEndpoint.getUserRoles(self.GetUserRoles.Args(sessionId))
        def hasRole(sessionId: String, role: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.hasRole(self.HasRole.Args(sessionId, role))
        def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
          servicePerEndpoint.hasRoles(self.HasRoles.Args(sessionId, roles))
        def hasRoleUser(username: String, roleName: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.hasRoleUser(self.HasRoleUser.Args(username, roleName))
        def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.hasAllRoleUser(self.HasAllRoleUser.Args(username, roleNames))
        def getAllUsername(): Future[xed.caas.domain.thrift.TListStringResult] =
          servicePerEndpoint.getAllUsername(self.GetAllUsername.Args())
        def getActiveUsername(from: Int, size: Int): Future[xed.caas.domain.thrift.TListUserResult] =
          servicePerEndpoint.getActiveUsername(self.GetActiveUsername.Args(from, size))
        def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.insertUserRoles(self.InsertUserRoles.Args(username, roleIds))
        def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.insertExpirableUserRoles(self.InsertExpirableUserRoles.Args(username, roleIds))
        def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.insertUserRole(self.InsertUserRole.Args(username, role, expireTime, force))
        def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.deleteUserRoles(self.DeleteUserRoles.Args(username, roleIds))
        def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] =
          servicePerEndpoint.getListUserRole(self.GetListUserRole.Args(notInRoleIds, inRoleIds, from, size))
        def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] =
          servicePerEndpoint.searchListUserRole(self.SearchListUserRole.Args(usernameSearchKey, notInRoleIds, inRoleIds, from, size))
        def resetPasswordUser(username: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.resetPasswordUser(self.ResetPasswordUser.Args(username, newPassword))
        def updatePasswordUser(username: String, oldPassword: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.updatePasswordUser(self.UpdatePasswordUser.Args(username, oldPassword, newPassword))
        def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): Future[xed.caas.domain.thrift.TBoolResult] =
          servicePerEndpoint.deleteAllExpiredUserRole(self.DeleteAllExpiredUserRole.Args(defaultRoleId, maxTime))
        def getAllRoleInfo(username: String): Future[xed.caas.domain.thrift.TListRoleInfoResult] =
          servicePerEndpoint.getAllRoleInfo(self.GetAllRoleInfo.Args(username))
        def getAllPermission(username: String): Future[xed.caas.domain.thrift.TListStringResult] =
          servicePerEndpoint.getAllPermission(self.GetAllPermission.Args(username))

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  object ReqRepMethodPerEndpoint {

    def apply(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      new ReqRepMethodPerEndpointImpl(servicePerEndpoint) { }

    /**
     * Use `ReqRepMethodPerEndpoint.apply()` instead of this constructor.
     */
    class ReqRepMethodPerEndpointImpl protected (servicePerEndpoint: ReqRepServicePerEndpoint)
      extends MethodPerEndpoint {

        def ping(): Future[String] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Ping.Args())
          servicePerEndpoint.ping(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.RenewSession.Args(oldSessionId, sessionTimeout))
          servicePerEndpoint.renewSession(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def login(username: String, password: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Login.Args(username, password, sessionTimeout))
          servicePerEndpoint.login(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def loginOAuth(username: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.LoginOAuth.Args(username, sessionTimeout))
          servicePerEndpoint.loginOAuth(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserAuthResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.LoginWithOAuth.Args(oauthType, id, token, sessionTimeout, password))
          servicePerEndpoint.loginWithOAuth(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def register(username: String, password: String): Future[xed.caas.domain.thrift.TUserInfoResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Register.Args(username, password))
          servicePerEndpoint.register(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isCredentialDefault(oauthType: String, username: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsCredentialDefault.Args(oauthType, username))
          servicePerEndpoint.isCredentialDefault(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def deleteUser(username: String): Future[xed.caas.domain.thrift.TResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DeleteUser.Args(username))
          servicePerEndpoint.deleteUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserInfoResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.RegisterWithOAuth.Args(oauthType, id, token, password))
          servicePerEndpoint.registerWithOAuth(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserWithSessionId(sessionId: String): Future[xed.caas.domain.thrift.TUserInfoResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserWithSessionId.Args(sessionId))
          servicePerEndpoint.getUserWithSessionId(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserWithUsername(username: String): Future[xed.caas.domain.thrift.TUserInfoResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserWithUsername.Args(username))
          servicePerEndpoint.getUserWithUsername(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def logout(sessionId: String): Future[xed.caas.domain.thrift.TResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.Logout.Args(sessionId))
          servicePerEndpoint.logout(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermitted(sessionId: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermitted.Args(sessionId, permission))
          servicePerEndpoint.isPermitted(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermitteds.Args(sessionId, permissions))
          servicePerEndpoint.isPermitteds(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermittedAll.Args(sessionId, permissions))
          servicePerEndpoint.isPermittedAll(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermittedUser(username: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermittedUser.Args(username, permission))
          servicePerEndpoint.isPermittedUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermittedsUser.Args(username, permissions))
          servicePerEndpoint.isPermittedsUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IsPermittedUserAll.Args(username, permissions))
          servicePerEndpoint.isPermittedUserAll(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getUserRoles(sessionId: String): Future[xed.caas.domain.thrift.TListStringResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetUserRoles.Args(sessionId))
          servicePerEndpoint.getUserRoles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def hasRole(sessionId: String, role: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.HasRole.Args(sessionId, role))
          servicePerEndpoint.hasRole(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.HasRoles.Args(sessionId, roles))
          servicePerEndpoint.hasRoles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def hasRoleUser(username: String, roleName: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.HasRoleUser.Args(username, roleName))
          servicePerEndpoint.hasRoleUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.HasAllRoleUser.Args(username, roleNames))
          servicePerEndpoint.hasAllRoleUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getAllUsername(): Future[xed.caas.domain.thrift.TListStringResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetAllUsername.Args())
          servicePerEndpoint.getAllUsername(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getActiveUsername(from: Int, size: Int): Future[xed.caas.domain.thrift.TListUserResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetActiveUsername.Args(from, size))
          servicePerEndpoint.getActiveUsername(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.InsertUserRoles.Args(username, roleIds))
          servicePerEndpoint.insertUserRoles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.InsertExpirableUserRoles.Args(username, roleIds))
          servicePerEndpoint.insertExpirableUserRoles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.InsertUserRole.Args(username, role, expireTime, force))
          servicePerEndpoint.insertUserRole(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DeleteUserRoles.Args(username, roleIds))
          servicePerEndpoint.deleteUserRoles(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetListUserRole.Args(notInRoleIds, inRoleIds, from, size))
          servicePerEndpoint.getListUserRole(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SearchListUserRole.Args(usernameSearchKey, notInRoleIds, inRoleIds, from, size))
          servicePerEndpoint.searchListUserRole(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def resetPasswordUser(username: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ResetPasswordUser.Args(username, newPassword))
          servicePerEndpoint.resetPasswordUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def updatePasswordUser(username: String, oldPassword: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.UpdatePasswordUser.Args(username, oldPassword, newPassword))
          servicePerEndpoint.updatePasswordUser(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): Future[xed.caas.domain.thrift.TBoolResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.DeleteAllExpiredUserRole.Args(defaultRoleId, maxTime))
          servicePerEndpoint.deleteAllExpiredUserRole(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getAllRoleInfo(username: String): Future[xed.caas.domain.thrift.TListRoleInfoResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetAllRoleInfo.Args(username))
          servicePerEndpoint.getAllRoleInfo(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getAllPermission(username: String): Future[xed.caas.domain.thrift.TListStringResult] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetAllPermission.Args(username))
          servicePerEndpoint.getAllPermission(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  class MethodIface(serviceIface: BaseServiceIface)
    extends FutureIface {
    def ping(): Future[String] =
      serviceIface.ping(self.Ping.Args())
    def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
      serviceIface.renewSession(self.RenewSession.Args(oldSessionId, sessionTimeout))
    def login(username: String, password: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
      serviceIface.login(self.Login.Args(username, password, sessionTimeout))
    def loginOAuth(username: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
      serviceIface.loginOAuth(self.LoginOAuth.Args(username, sessionTimeout))
    def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserAuthResult] =
      serviceIface.loginWithOAuth(self.LoginWithOAuth.Args(oauthType, id, token, sessionTimeout, password))
    def register(username: String, password: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
      serviceIface.register(self.Register.Args(username, password))
    def isCredentialDefault(oauthType: String, username: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.isCredentialDefault(self.IsCredentialDefault.Args(oauthType, username))
    def deleteUser(username: String): Future[xed.caas.domain.thrift.TResult] =
      serviceIface.deleteUser(self.DeleteUser.Args(username))
    def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserInfoResult] =
      serviceIface.registerWithOAuth(self.RegisterWithOAuth.Args(oauthType, id, token, password))
    def getUserWithSessionId(sessionId: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
      serviceIface.getUserWithSessionId(self.GetUserWithSessionId.Args(sessionId))
    def getUserWithUsername(username: String): Future[xed.caas.domain.thrift.TUserInfoResult] =
      serviceIface.getUserWithUsername(self.GetUserWithUsername.Args(username))
    def logout(sessionId: String): Future[xed.caas.domain.thrift.TResult] =
      serviceIface.logout(self.Logout.Args(sessionId))
    def isPermitted(sessionId: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.isPermitted(self.IsPermitted.Args(sessionId, permission))
    def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
      serviceIface.isPermitteds(self.IsPermitteds.Args(sessionId, permissions))
    def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.isPermittedAll(self.IsPermittedAll.Args(sessionId, permissions))
    def isPermittedUser(username: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.isPermittedUser(self.IsPermittedUser.Args(username, permission))
    def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
      serviceIface.isPermittedsUser(self.IsPermittedsUser.Args(username, permissions))
    def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.isPermittedUserAll(self.IsPermittedUserAll.Args(username, permissions))
    def getUserRoles(sessionId: String): Future[xed.caas.domain.thrift.TListStringResult] =
      serviceIface.getUserRoles(self.GetUserRoles.Args(sessionId))
    def hasRole(sessionId: String, role: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.hasRole(self.HasRole.Args(sessionId, role))
    def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult] =
      serviceIface.hasRoles(self.HasRoles.Args(sessionId, roles))
    def hasRoleUser(username: String, roleName: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.hasRoleUser(self.HasRoleUser.Args(username, roleName))
    def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.hasAllRoleUser(self.HasAllRoleUser.Args(username, roleNames))
    def getAllUsername(): Future[xed.caas.domain.thrift.TListStringResult] =
      serviceIface.getAllUsername(self.GetAllUsername.Args())
    def getActiveUsername(from: Int, size: Int): Future[xed.caas.domain.thrift.TListUserResult] =
      serviceIface.getActiveUsername(self.GetActiveUsername.Args(from, size))
    def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.insertUserRoles(self.InsertUserRoles.Args(username, roleIds))
    def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.insertExpirableUserRoles(self.InsertExpirableUserRoles.Args(username, roleIds))
    def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.insertUserRole(self.InsertUserRole.Args(username, role, expireTime, force))
    def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.deleteUserRoles(self.DeleteUserRoles.Args(username, roleIds))
    def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] =
      serviceIface.getListUserRole(self.GetListUserRole.Args(notInRoleIds, inRoleIds, from, size))
    def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable] =
      serviceIface.searchListUserRole(self.SearchListUserRole.Args(usernameSearchKey, notInRoleIds, inRoleIds, from, size))
    def resetPasswordUser(username: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.resetPasswordUser(self.ResetPasswordUser.Args(username, newPassword))
    def updatePasswordUser(username: String, oldPassword: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.updatePasswordUser(self.UpdatePasswordUser.Args(username, oldPassword, newPassword))
    def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): Future[xed.caas.domain.thrift.TBoolResult] =
      serviceIface.deleteAllExpiredUserRole(self.DeleteAllExpiredUserRole.Args(defaultRoleId, maxTime))
    def getAllRoleInfo(username: String): Future[xed.caas.domain.thrift.TListRoleInfoResult] =
      serviceIface.getAllRoleInfo(self.GetAllRoleInfo.Args(username))
    def getAllPermission(username: String): Future[xed.caas.domain.thrift.TListStringResult] =
      serviceIface.getAllPermission(self.GetAllPermission.Args(username))
  }

  implicit object MethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.MethodPerEndpointBuilder[ServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2018-01-12")
  implicit object ThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ThriftServiceBuilder[ServicePerEndpoint, TCaasService[Future]] {
    def build(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  implicit object ReqRepMethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepMethodPerEndpointBuilder[ReqRepServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use ReqRepMethodPerEndpointBuilder", "2018-01-12")
  implicit object ReqRepThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepThriftServiceBuilder[ReqRepServicePerEndpoint, TCaasService[Future]] {
    def build(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2017-11-07")
  implicit object MethodIfaceBuilder
    extends com.twitter.finagle.thrift.MethodIfaceBuilder[ServiceIface, TCaasService[Future]] {
    def newMethodIface(serviceIface: ServiceIface): MethodIface =
      new MethodIface(serviceIface)
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  trait FutureIface
    extends TCaasService[Future] {
    
    def ping(): Future[String]
    
    def renewSession(oldSessionId: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def login(username: String, password: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def loginOAuth(username: String, sessionTimeout: Option[Long] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def loginWithOAuth(oauthType: String, id: String, token: String, sessionTimeout: Option[Long] = None, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserAuthResult]
    
    def register(username: String, password: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def isCredentialDefault(oauthType: String, username: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteUser(username: String): Future[xed.caas.domain.thrift.TResult]
    
    def registerWithOAuth(oauthType: String, id: String, token: String, password: Option[String] = None): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def getUserWithSessionId(sessionId: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def getUserWithUsername(username: String): Future[xed.caas.domain.thrift.TUserInfoResult]
    
    def logout(sessionId: String): Future[xed.caas.domain.thrift.TResult]
    
    def isPermitted(sessionId: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermitteds(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def isPermittedAll(sessionId: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermittedUser(username: String, permission: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def isPermittedsUser(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def isPermittedUserAll(username: String, permissions: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getUserRoles(sessionId: String): Future[xed.caas.domain.thrift.TListStringResult]
    
    def hasRole(sessionId: String, role: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def hasRoles(sessionId: String, roles: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TListBoolResult]
    
    def hasRoleUser(username: String, roleName: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def hasAllRoleUser(username: String, roleNames: Seq[String] = Seq[String]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getAllUsername(): Future[xed.caas.domain.thrift.TListStringResult]
    
    def getActiveUsername(from: Int, size: Int): Future[xed.caas.domain.thrift.TListUserResult]
    
    def insertUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def insertExpirableUserRoles(username: String, roleIds: Map[Int, Long] = Map[Int, Long]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def insertUserRole(username: String, role: Int, expireTime: Long, force: Boolean): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteUserRoles(username: String, roleIds: Set[Int] = Set[Int]()): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getListUserRole(notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable]
    
    def searchListUserRole(usernameSearchKey: String, notInRoleIds: Option[Seq[Int]] = None, inRoleIds: Option[Seq[Int]] = None, from: Int, size: Int): Future[xed.caas.domain.thrift.TUserInfoPageable]
    
    def resetPasswordUser(username: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def updatePasswordUser(username: String, oldPassword: String, newPassword: String): Future[xed.caas.domain.thrift.TBoolResult]
    
    def deleteAllExpiredUserRole(defaultRoleId: Int, maxTime: Long): Future[xed.caas.domain.thrift.TBoolResult]
    
    def getAllRoleInfo(username: String): Future[xed.caas.domain.thrift.TListRoleInfoResult]
    
    def getAllPermission(username: String): Future[xed.caas.domain.thrift.TListStringResult]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      clientParam: RichClientParam)
    extends TCaasService$FinagleClient(service, clientParam)
    with FutureIface
    with MethodPerEndpoint {

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory = Protocols.binaryFactory(),
      serviceName: String = "TCaasService",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver,
      responseClassifier: ctfs.ResponseClassifier = ctfs.ResponseClassifier.Default
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats,
        responseClassifier = responseClassifier
      )
    )

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String,
      stats: com.twitter.finagle.stats.StatsReceiver
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats
      )
    )
  }

  class FinagledService(
      iface: TCaasService[Future],
      serverParam: RichServerParam)
    extends TCaasService$FinagleService(iface, serverParam) {

    @deprecated("Use com.twitter.finagle.thrift.RichServerParam", "2017-08-16")
    def this(
      iface: TCaasService[Future],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String = "TCaasService"
    ) = this(iface, RichServerParam(protocolFactory, serviceName))
  }
}
